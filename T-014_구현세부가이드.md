# T-014 구현 세부 가이드

## 1. REST API 인증 미들웨어

### 1.1 Bearer 토큰 기반 인증

```typescript
// server/src/middleware/expressAuth.ts
/**
 * Express REST API용 JWT 인증 미들웨어
 *
 * Bearer 토큰에서 JWT를 추출하고 검증합니다.
 * - 성공: req.user에 사용자 정보 저장
 * - 실패: 401 Unauthorized 응답
 */

import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import { logger } from '../utils/logger';

export interface AuthenticatedRequest extends Request {
  user: {
    id: string;
    role?: 'mobile' | 'monitor' | 'admin';
    scopes: string[];
    deviceId?: string;
    screenId?: string;
  };
}

/**
 * JWT 토큰 검증 미들웨어
 *
 * @example
 * app.use('/api/', expressAuthMiddleware(config.jwtSecret));
 */
export function expressAuthMiddleware(jwtSecret: string) {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      // 1. Authorization 헤더에서 토큰 추출
      const authHeader = req.headers.authorization;
      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        logger.warn('auth.missing_token: ip=%s, path=%s', req.ip, req.path);
        return res.status(401).json({
          ok: false,
          reason: 'unauthorized',
          message: 'Authorization 헤더가 없거나 형식이 잘못되었습니다.',
        });
      }

      const token = authHeader.substring(7);  // 'Bearer ' 제거

      // 2. JWT 검증
      const decoded = jwt.verify(token, jwtSecret) as any;

      // 3. req.user에 정보 저장
      (req as AuthenticatedRequest).user = {
        id: decoded.sub || decoded.id,
        role: decoded.role,
        scopes: decoded.scopes || [],
        deviceId: decoded.deviceId,
        screenId: decoded.screenId,
      };

      logger.debug('auth.success: userId=%s, scopes=%s, ip=%s',
        decoded.sub, decoded.scopes?.join(','), req.ip);

      next();
    } catch (error) {
      if (error instanceof jwt.TokenExpiredError) {
        logger.warn('auth.token_expired: ip=%s, path=%s', req.ip, req.path);
        return res.status(401).json({
          ok: false,
          reason: 'token_expired',
          message: '토큰이 만료되었습니다.',
        });
      }

      if (error instanceof jwt.JsonWebTokenError) {
        logger.warn('auth.invalid_token: error=%s, ip=%s', error.message, req.ip);
        return res.status(401).json({
          ok: false,
          reason: 'invalid_token',
          message: '유효하지 않은 토큰입니다.',
        });
      }

      logger.error('auth.error: error=%s, ip=%s', (error as Error).message, req.ip);
      return res.status(500).json({
        ok: false,
        reason: 'internal_error',
      });
    }
  };
}

/**
 * 특정 권한(scope)을 요구하는 미들웨어
 *
 * @example
 * router.post('/trigger', requireScope('display:*'), handler);
 */
export function requireScope(requiredScope: string) {
  return (req: Request, res: Response, next: NextFunction) => {
    const authReq = req as AuthenticatedRequest;

    if (!authReq.user) {
      return res.status(401).json({
        ok: false,
        reason: 'unauthorized',
      });
    }

    const hasScope = authReq.user.scopes.includes(requiredScope) ||
                    authReq.user.scopes.includes('display:*');

    if (!hasScope) {
      logger.warn('auth.insufficient_permission: userId=%s, requiredScope=%s, ip=%s',
        authReq.user.id, requiredScope, req.ip);
      return res.status(403).json({
        ok: false,
        reason: 'forbidden',
        message: `필요한 권한이 없습니다: ${requiredScope}`,
      });
    }

    next();
  };
}
```

---

## 2. Zod 검증 스키마

### 2.1 요청 본문 검증

```typescript
// server/src/schemas/validation.ts
/**
 * 모든 REST API 요청에 대한 Zod 검증 스키마
 *
 * 장점:
 * - 타입 안전성
 * - 런타임 검증
 * - 명확한 에러 메시지
 */

import { z } from 'zod';

// 공통 스키마
const UUIDSchema = z.string().uuid('유효한 UUID 형식이 아닙니다');
const ScreenIdSchema = z.string()
  .regex(/^screen:[a-z0-9-]+:[a-z0-9-]+$/, 'screenId 형식이 잘못되었습니다');
const JobNoSchema = z.string().min(1).max(50, '주문번호는 1-50자');

// A. 디스플레이 등록
export const RegisterDisplaySchema = z.object({
  deviceId: UUIDSchema.describe('디바이스 고유 ID'),
  name: z.string()
    .min(1, '이름은 필수입니다')
    .max(100, '이름은 100자 이내'),
  purpose: z.string()
    .min(1, '용도는 필수입니다')
    .max(200, '용도는 200자 이내'),
  orgId: z.string()
    .min(1, '조직 ID는 필수입니다')
    .max(50),
  lineId: z.string()
    .min(1, 'lineId는 필수입니다')
    .max(50),
});

export type RegisterDisplayRequest = z.infer<typeof RegisterDisplaySchema>;

// B. 페어링 승인
export const PairingApproveSchema = z.object({
  sessionId: UUIDSchema.describe('페어링 세션 ID'),
  code: z.string()
    .length(6, '코드는 정확히 6자리여야 합니다')
    .regex(/^\d+$/, '코드는 숫자만 포함해야 합니다'),
});

export type PairingApproveRequest = z.infer<typeof PairingApproveSchema>;

// C. 트리거 (네비게이션)
export const TriggerSchema = z.object({
  screenId: ScreenIdSchema.describe('대상 화면 ID'),
  jobNo: JobNoSchema.describe('주문번호'),
});

export type TriggerRequest = z.infer<typeof TriggerSchema>;

// D. 디스플레이 목록 조회 (쿼리 파라미터)
export const GetDisplaysQuerySchema = z.object({
  lineId: z.string().max(50).optional().describe('라인 ID로 필터링'),
  onlineOnly: z.enum(['true', 'false']).optional().default('true').describe('온라인만 표시'),
});

export type GetDisplaysQuery = z.infer<typeof GetDisplaysQuerySchema>;

/**
 * Zod 검증 헬퍼 함수
 *
 * @example
 * const parsed = await validateRequest(req.body, RegisterDisplaySchema);
 * if (!parsed.success) {
 *   return res.status(400).json(parsed.error);
 * }
 */
export function validateRequest<T>(
  data: unknown,
  schema: z.ZodSchema<T>
): { success: true; data: T } | { success: false; errors: any[] } {
  const result = schema.safeParse(data);

  if (!result.success) {
    return {
      success: false,
      errors: result.error.errors.map(err => ({
        field: err.path.join('.'),
        message: err.message,
        code: err.code,
      })),
    };
  }

  return { success: true, data: result.data };
}
```

---

## 3. 에러 응답 표준화

### 3.1 에러 타입 정의

```typescript
// server/src/types/errors.ts
/**
 * REST API 에러 응답 표준
 */

export type ErrorReason =
  | 'validation_error'
  | 'unauthorized'
  | 'forbidden'
  | 'not_found'
  | 'conflict'
  | 'rate_limit_exceeded'
  | 'internal_error'
  | 'service_unavailable';

export interface ApiErrorResponse {
  ok: false;
  reason: ErrorReason;
  message?: string;
  details?: {
    field?: string;
    message: string;
    code?: string;
  }[];
  txId?: string;  // 추적 ID
}

export interface ApiSuccessResponse<T = any> {
  ok: true;
  data?: T;
  txId?: string;  // 추적 ID
}

/**
 * REST API 에러 클래스
 *
 * @example
 * throw new ApiError('validation_error', 'Invalid input', 400);
 */
export class ApiError extends Error {
  constructor(
    public reason: ErrorReason,
    public message: string,
    public statusCode: number = 400,
    public details?: any[]
  ) {
    super(message);
    this.name = 'ApiError';
  }
}
```

### 3.2 에러 핸들러 미들웨어

```typescript
// server/src/middleware/errorHandler.ts
/**
 * 모든 Express 라우트의 에러를 잡아서 표준화된 응답 반환
 */

import { Request, Response, NextFunction } from 'express';
import { ApiError, ApiErrorResponse } from '../types/errors';
import { logger } from '../utils/logger';

export function errorHandler(
  error: Error,
  _req: Request,
  res: Response,
  _next: NextFunction
) {
  if (error instanceof ApiError) {
    // 예상된 에러
    logger.warn('api_error: reason=%s, message=%s, statusCode=%d',
      error.reason, error.message, error.statusCode);

    const response: ApiErrorResponse = {
      ok: false,
      reason: error.reason,
      message: error.message,
    };

    if (error.details) {
      response.details = error.details;
    }

    return res.status(error.statusCode).json(response);
  }

  // 예상치 못한 에러
  logger.error('unexpected_error: name=%s, message=%s, stack=%s',
    error.name, error.message, error.stack);

  const response: ApiErrorResponse = {
    ok: false,
    reason: 'internal_error',
    message: '서버 오류가 발생했습니다.',
  };

  res.status(500).json(response);
}

// 사용 방법:
// app.use(errorHandler);  // 모든 라우트 뒤에 등록
```

---

## 4. 레이트 리미팅 설정

### 4.1 세분화된 레이트 리미팅

```typescript
// server/src/middleware/rateLimiting.ts
/**
 * 엔드포인트별 세분화된 레이트 리미팅
 *
 * 설계:
 * - 트리거: IP 초당 10회, 사용자 분당 100회
 * - 디스플레이: IP 분당 60회 (30초 heartbeat)
 * - 페어링: IP 분당 20회
 */

import rateLimit, { RateLimitRequestHandler } from 'express-rate-limit';
import { Request, Response } from 'express';
import { logger } from '../utils/logger';

// 기본 Store (메모리 기반, 프로덕션은 Redis 사용)
let requestLog = new Map<string, number[]>();

/**
 * IP 기반 레이트 리미팅: 트리거 API (초당 10회)
 */
export const triggerIpLimiter: RateLimitRequestHandler = rateLimit({
  windowMs: 1 * 1000,       // 1초
  max: 10,                  // IP당 10회
  message: '너무 많은 요청입니다 (IP당 초당 10회)',
  standardHeaders: false,   // RateLimit-* 헤더 비활성화
  skip: (req: Request) => {
    // 어드민은 제외 (선택사항)
    return (req as any).user?.role === 'admin';
  },
  handler: (_req: Request, res: Response) => {
    logger.warn('rate_limit.trigger_ip_exceeded: ip=%s', _req.ip);
    res.status(429).json({
      ok: false,
      reason: 'rate_limit_exceeded',
      message: '요청 횟수 제한을 초과했습니다.',
      retryAfter: 1,
    });
  },
});

/**
 * 사용자 기반 레이트 리미팅: 트리거 API (분당 100회)
 */
export const triggerUserLimiter: RateLimitRequestHandler = rateLimit({
  windowMs: 60 * 1000,      // 1분
  max: 100,                 // 사용자당 100회
  message: '너무 많은 요청입니다 (분당 100회)',
  keyGenerator: (req: Request) => {
    // 사용자 ID로 그룹화, 없으면 IP 사용
    return (req as any).user?.id || req.ip || 'unknown';
  },
  handler: (_req: Request, res: Response) => {
    logger.warn('rate_limit.trigger_user_exceeded: userId=%s, ip=%s',
      (_req as any).user?.id, _req.ip);
    res.status(429).json({
      ok: false,
      reason: 'rate_limit_exceeded',
      message: '요청 횟수 제한을 초과했습니다.',
      retryAfter: 60,
    });
  },
});

/**
 * IP 기반 레이트 리미팅: 디스플레이 등록 (분당 60회)
 */
export const displayLimiter: RateLimitRequestHandler = rateLimit({
  windowMs: 60 * 1000,      // 1분
  max: 60,                  // IP당 60회
  message: '너무 많은 요청입니다 (분당 60회)',
  keyGenerator: (req: Request) => {
    // deviceId 기반 (더 정확)
    const deviceId = (req.body as any)?.deviceId;
    return deviceId || req.ip || 'unknown';
  },
  handler: (_req: Request, res: Response) => {
    logger.warn('rate_limit.display_exceeded: deviceId=%s, ip=%s',
      (_req.body as any)?.deviceId, _req.ip);
    res.status(429).json({
      ok: false,
      reason: 'rate_limit_exceeded',
      message: '요청 횟수 제한을 초과했습니다 (분당 60회).',
      retryAfter: 60,
    });
  },
});

/**
 * IP 기반 레이트 리미팅: 페어링 (분당 20회)
 */
export const pairingLimiter: RateLimitRequestHandler = rateLimit({
  windowMs: 60 * 1000,      // 1분
  max: 20,                  // IP당 20회
  message: '너무 많은 요청입니다 (분당 20회)',
  handler: (_req: Request, res: Response) => {
    logger.warn('rate_limit.pairing_exceeded: ip=%s', _req.ip);
    res.status(429).json({
      ok: false,
      reason: 'rate_limit_exceeded',
      message: '요청 횟수 제한을 초과했습니다.',
      retryAfter: 60,
    });
  },
});
```

---

## 5. 라우터 구현 예제

### 5.1 디스플레이 라우터 (상세)

```typescript
// server/src/routes/displays.ts
/**
 * 디스플레이 등록 및 관리 라우터
 *
 * - POST /api/displays/register: 디스플레이 등록 (heartbeat)
 * - GET /api/displays: 디스플레이 목록 조회
 */

import express, { Request, Response, NextFunction } from 'express';
import { logger } from '../utils/logger';
import { displayService } from '../services/displayService';
import { expressAuthMiddleware, AuthenticatedRequest } from '../middleware/expressAuth';
import { displayLimiter } from '../middleware/rateLimiting';
import { RegisterDisplaySchema, GetDisplaysQuerySchema, validateRequest } from '../schemas/validation';
import { ApiError } from '../types/errors';

const router = express.Router();

/**
 * POST /api/displays/register
 *
 * 브라우저 확장이 자신을 서버에 등록합니다.
 *
 * 요청:
 * {
 *   "deviceId": "550e8400-e29b-41d4-a716-446655440000",
 *   "name": "Production Line A",
 *   "purpose": "order-display",
 *   "orgId": "org-001",
 *   "lineId": "line-001"
 * }
 *
 * 응답 (성공):
 * {
 *   "ok": true,
 *   "screenId": "screen:org-001:line-001",
 *   "status": "registered"
 * }
 *
 * 응답 (실패):
 * {
 *   "ok": false,
 *   "reason": "validation_error",
 *   "details": [
 *     { "field": "deviceId", "message": "유효한 UUID 형식이 아닙니다" }
 *   ]
 * }
 */
router.post(
  '/register',
  displayLimiter,
  async (
    req: Request,
    res: Response,
    next: NextFunction
  ) => {
    try {
      // 1. 입력 검증
      const validated = validateRequest(req.body, RegisterDisplaySchema);
      if (!validated.success) {
        logger.warn('displays.register.validation_error: errors=%s, ip=%s',
          JSON.stringify(validated.errors), req.ip);
        return res.status(400).json({
          ok: false,
          reason: 'validation_error',
          details: validated.errors,
        });
      }

      const { deviceId, name, purpose, orgId, lineId } = validated.data;
      const screenId = `screen:${orgId}:${lineId}`;

      // 2. 디스플레이 등록
      const result = await displayService.register({
        deviceId,
        screenId,
        name,
        purpose,
        orgId,
        lineId,
      });

      // 3. 로깅
      logger.info('displays.register.success: deviceId=%s, screenId=%s, ip=%s',
        deviceId, screenId, req.ip);

      // 4. 응답
      res.status(200).json({
        ok: true,
        screenId: result.screenId,
        status: result.status,
      });
    } catch (error) {
      logger.error('displays.register.error: error=%s, ip=%s',
        (error as Error).message, req.ip);
      next(error);
    }
  }
);

/**
 * GET /api/displays
 *
 * 인증된 사용자가 접근 가능한 디스플레이 목록을 조회합니다.
 *
 * 쿼리 파라미터:
 * - lineId: 특정 라인의 디스플레이만 조회
 * - onlineOnly: 'true' (기본값) 또는 'false'
 *
 * 응답:
 * {
 *   "ok": true,
 *   "displays": [
 *     {
 *       "screenId": "screen:org:line",
 *       "name": "Production Line A",
 *       "purpose": "order-display",
 *       "online": true,
 *       "lastSeen": "2025-10-25T10:30:00.000Z"
 *     }
 *   ]
 * }
 */
router.get(
  '/',
  expressAuthMiddleware(process.env.SOCKET_JWT_SECRET || ''),
  async (
    req: Request,
    res: Response,
    next: NextFunction
  ) => {
    try {
      const authReq = req as AuthenticatedRequest;

      // 1. 쿼리 파라미터 검증
      const validated = validateRequest(req.query, GetDisplaysQuerySchema);
      if (!validated.success) {
        return res.status(400).json({
          ok: false,
          reason: 'validation_error',
          details: validated.errors,
        });
      }

      const { lineId, onlineOnly } = validated.data;

      // 2. 디스플레이 목록 조회
      const displays = await displayService.getDisplays({
        lineId,
        onlineOnly: onlineOnly === 'true',
      });

      // 3. 로깅
      logger.info('displays.list.success: userId=%s, count=%d, ip=%s',
        authReq.user.id, displays.length, req.ip);

      // 4. 응답
      res.status(200).json({
        ok: true,
        displays: displays.map(d => ({
          screenId: d.screenId,
          name: d.name,
          purpose: d.purpose,
          online: d.status === 'online',
          lastSeen: d.lastSeenAt.toISOString(),
        })),
      });
    } catch (error) {
      logger.error('displays.list.error: error=%s, ip=%s',
        (error as Error).message, req.ip);
      next(error);
    }
  }
);

export const displayRoutes = router;
```

---

## 6. 데이터베이스 스키마 (Option B: SQLite)

### 6.1 마이그레이션 파일

```sql
-- server/migrations/001_initial_schema.sql
/**
 * T-014 초기 스키마
 *
 * 테이블:
 * - displays: 등록된 디스플레이 정보
 * - pair_sessions: QR 페어링 세션
 * - trigger_logs: 트리거 이력 (감시/감사용)
 */

-- 디스플레이 테이블
CREATE TABLE IF NOT EXISTS displays (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  device_id TEXT UNIQUE NOT NULL COMMENT '디바이스 고유 ID (UUID)',
  screen_id TEXT NOT NULL COMMENT '화면 ID (screen:orgId:lineId)',
  name TEXT NOT NULL COMMENT '디스플레이 이름',
  purpose TEXT NOT NULL COMMENT '용도',
  org_id TEXT NOT NULL COMMENT '조직 ID',
  line_id TEXT NOT NULL COMMENT '라인 ID',
  status TEXT NOT NULL DEFAULT 'online' COMMENT 'online|offline',
  last_seen_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '마지막 갱신 시간',
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '생성 시간',
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '수정 시간'
);

CREATE INDEX IF NOT EXISTS idx_displays_screen_id ON displays(screen_id);
CREATE INDEX IF NOT EXISTS idx_displays_line_id ON displays(line_id);
CREATE INDEX IF NOT EXISTS idx_displays_last_seen_at ON displays(last_seen_at);
CREATE INDEX IF NOT EXISTS idx_displays_status ON displays(status);

-- 페어링 세션 테이블
CREATE TABLE IF NOT EXISTS pair_sessions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id TEXT UNIQUE NOT NULL COMMENT '세션 ID (UUID)',
  code TEXT NOT NULL COMMENT '6자리 코드',
  status TEXT NOT NULL DEFAULT 'pending' COMMENT 'pending|approved|expired',
  token TEXT COMMENT 'JWT 토큰 (승인 후)',
  approved_by TEXT COMMENT '승인한 사용자 ID',
  expires_at TIMESTAMP NOT NULL COMMENT '만료 시간 (5분)',
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '생성 시간',
  approved_at TIMESTAMP COMMENT '승인 시간'
);

CREATE INDEX IF NOT EXISTS idx_pair_sessions_id ON pair_sessions(session_id);
CREATE INDEX IF NOT EXISTS idx_pair_sessions_expires_at ON pair_sessions(expires_at);
CREATE INDEX IF NOT EXISTS idx_pair_sessions_status ON pair_sessions(status);

-- 트리거 로그 테이블 (감시/감시용)
CREATE TABLE IF NOT EXISTS trigger_logs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  tx_id TEXT UNIQUE NOT NULL COMMENT '트랜잭션 ID (UUID)',
  screen_id TEXT NOT NULL COMMENT '대상 화면 ID',
  job_no TEXT NOT NULL COMMENT '주문번호',
  user_id TEXT NOT NULL COMMENT '요청 사용자 ID',
  status TEXT NOT NULL COMMENT 'delivered|missed',
  client_count INTEGER COMMENT '수신한 클라이언트 수',
  ip_address TEXT COMMENT '요청 IP',
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  ack_received_at TIMESTAMP COMMENT 'ACK 수신 시간',
  ack_result TEXT COMMENT 'success|failed|timeout'
);

CREATE INDEX IF NOT EXISTS idx_trigger_logs_tx_id ON trigger_logs(tx_id);
CREATE INDEX IF NOT EXISTS idx_trigger_logs_screen_id ON trigger_logs(screen_id);
CREATE INDEX IF NOT EXISTS idx_trigger_logs_user_id ON trigger_logs(user_id);
CREATE INDEX IF NOT EXISTS idx_trigger_logs_created_at ON trigger_logs(created_at);
```

---

## 7. 통합 테스트 예제

### 7.1 전체 API 플로우 테스트

```typescript
// server/src/__tests__/t014.integration.test.ts
/**
 * T-014 전체 API 플로우 통합 테스트
 *
 * 시나리오:
 * 1. 디스플레이 등록 (heartbeat)
 * 2. QR 페어링 생성 및 승인
 * 3. 트리거 발행 (navigate 이벤트 전송)
 * 4. ACK 수신 확인
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import jwt from 'jsonwebtoken';
import { io as ioClient, Socket as ClientSocket } from 'socket.io-client';
import { Server as SocketIOServer } from 'socket.io';

describe('T-014 Integration Tests', () => {
  let app: any;
  let server: any;
  let io: SocketIOServer;
  let displaySocket: ClientSocket;
  let authToken: string;
  let deviceId: string;
  let screenId: string;

  beforeAll(async () => {
    // 앱 초기화 (실제로는 별도의 테스트 서버 필요)
    // ...
  });

  it('A. 디스플레이 등록 (heartbeat)', async () => {
    deviceId = '550e8400-e29b-41d4-a716-446655440000';
    screenId = 'screen:org-001:line-001';

    const response = await request(app)
      .post('/api/displays/register')
      .send({
        deviceId,
        name: 'Display 1',
        purpose: 'order-display',
        orgId: 'org-001',
        lineId: 'line-001',
      });

    expect(response.status).toBe(200);
    expect(response.body.ok).toBe(true);
    expect(response.body.screenId).toBe(screenId);
  });

  it('B. QR 페어링 요청', async () => {
    // 사용자 토큰 생성
    authToken = jwt.sign({
      sub: 'user-001',
      role: 'admin',
      scopes: ['display:*'],
    }, 'test-secret');

    const response = await request(app)
      .post('/api/pair/qr')
      .set('Authorization', `Bearer ${authToken}`);

    expect(response.status).toBe(200);
    expect(response.body.ok).toBe(true);
    expect(response.body.sessionId).toBeDefined();
    expect(response.body.code).toMatch(/^\d{6}$/);
  });

  it('C. 페어링 승인', async () => {
    // 이전 테스트에서 sessionId와 code 획득
    const sessionId = 'session-id-from-previous-test';
    const code = 'code-from-previous-test';

    const response = await request(app)
      .post('/api/pair/approve')
      .set('Authorization', `Bearer ${authToken}`)
      .send({
        sessionId,
        code,
      });

    expect(response.status).toBe(200);
    expect(response.body.ok).toBe(true);
    expect(response.body.token).toBeDefined();
  });

  it('D. 트리거 발행 (navigate 이벤트)', async () => {
    const response = await request(app)
      .post('/api/trigger')
      .set('Authorization', `Bearer ${authToken}`)
      .send({
        screenId,
        jobNo: 'JOB-001',
      });

    expect(response.status).toBe(200);
    expect(response.body.ok).toBe(true);
    expect(response.body.txId).toBeDefined();
  });

  it('E. 레이트 리미팅 확인', async () => {
    // 초당 10회 이상 요청
    const promises = [];
    for (let i = 0; i < 15; i++) {
      promises.push(
        request(app)
          .post('/api/trigger')
          .set('Authorization', `Bearer ${authToken}`)
          .send({
            screenId,
            jobNo: `JOB-${i}`,
          })
      );
    }

    const results = await Promise.all(promises);
    const successCount = results.filter(r => r.status === 200).length;
    const rateLimitedCount = results.filter(r => r.status === 429).length;

    expect(successCount).toBeLessThanOrEqual(10);
    expect(rateLimitedCount).toBeGreaterThan(0);
  });

  afterAll(async () => {
    // 정리
    if (displaySocket) {
      displaySocket.disconnect();
    }
  });
});
```

---

## 8. 주요 고려사항

### 8.1 온라인 상태 관리

```typescript
// 디스플레이 온라인 상태 판정 로직
const OFFLINE_THRESHOLD = 60 * 1000;  // 60초

function isDisplayOnline(lastSeenAt: Date): boolean {
  return Date.now() - lastSeenAt.getTime() < OFFLINE_THRESHOLD;
}

// 정기적으로 오프라인 상태 확인 (5분마다)
setInterval(() => {
  displayService.cleanupOfflineDisplays(30 * 60 * 1000);  // 30분 이상 offline 삭제
}, 5 * 60 * 1000);
```

### 8.2 페어링 세션 만료

```typescript
// 5분 자동 만료
setTimeout(() => {
  const session = pairingService.getSession(sessionId);
  if (session && session.status === 'pending') {
    pairingService.expireSession(sessionId);
  }
}, 5 * 60 * 1000);
```

### 8.3 트리거 권한 검증

```typescript
// screenId 권한 확인
const requiredScope = `display:${screenId}`;
const hasPermission = userScopes.includes(requiredScope) ||
                     userScopes.includes('display:*');

if (!hasPermission) {
  throw new ApiError(
    'forbidden',
    `필요한 권한 없음: ${requiredScope}`,
    403
  );
}
```

---

이 가이드를 따라 T-014를 구현하면 됩니다!
