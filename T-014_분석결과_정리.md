# T-014 "디스플레이 등록, 페어링 및 트리거 API" 아키텍처 분석 결과

## 📋 분석 개요

**분석 대상:** T-014 태스크 (Importance: MUST, Complexity: 7/10, Urgency: 8/10)

**분석 범위:** 기존 코드베이스 구조 + T-012, T-013 통합 설계

**분석 산출물:**
1. `T-014_아키텍처분석.md` (메인 분석 문서, 상세)
2. `T-014_구현세부가이드.md` (구현 가이드, 코드 예제)
3. `T-014_아키텍처분석_요약.md` (핵심 요약, 빠른 참조)

---

## 🎯 분석 결론

### A. 기존 코드베이스 활용도

| 항목 | 상태 | 활용 비중 |
|-----|------|---------|
| Socket.IO 기본 설정 | ✅ T-012 완료 | 재사용 100% |
| 채널 관리 | ✅ T-013 완료 | 재사용 100% (emitToChannel) |
| JWT 인증 | ✅ 구현됨 | 기반으로 확장 |
| 로거/설정 | ✅ 구현됨 | 재사용 100% |
| 에러 처리 | ⚠️ 부분 | 표준화 필요 |
| **새로 구현** | ❌ 필요 | 40% 분량 |

**결론:** 기존 코드베이스가 잘 준비되어 있음. T-014는 REST API 레이어 추가에 집중하면 됨.

---

### B. 주요 발견사항

#### 1️⃣ 기존 Express 구조의 한계
```typescript
// 현재 (index.ts에 모두 포함)
app.get('/health', ...)
app.get('/status', ...)
app.get('/api/channels/:screenId', ...)

// 필요 (라우터 분리)
app.use('/api/displays', displayRoutes)
app.use('/api/pair', pairingRoutes)
app.use('/api/trigger', triggerRoutes)
```

**영향:** 라우터 파일 구조 리팩토링 필수 (1일)

#### 2️⃣ REST API 인증 부재
```typescript
// 현재: Socket.IO 레벨만 있음
socket.on('auth', handleDisplayAuth)

// 필요: Express 미들웨어
app.use('/api/', expressAuthMiddleware)

// Bearer 토큰 검증
Authorization: Bearer <JWT>
```

**영향:** expressAuthMiddleware 새로 구현 필요

#### 3️⃣ 레이트 리미팅 미분화
```typescript
// 현재: 일괄 적용
app.use(rateLimit({ max: 100 / 15분 }))

// 필요: 엔드포인트별 세분화
- /api/trigger: 초당 10회 (IP), 분당 100회 (사용자)
- /api/displays/register: 분당 60회 (heartbeat용)
- /api/pair/*: 분당 20회
```

**영향:** 레이트 리미팅 전략 변경

#### 4️⃣ 저장소 선택 필요
```typescript
// 현재: Socket.IO 메모리만 사용
io.of('/display').adapter.rooms

// 필요: 디스플레이/페어링 세션 영속화
- displays 테이블
- pair_sessions 테이블
- trigger_logs 테이블 (감시용)
```

**권장:** 인메모리(개발) → SQLite(테스트) → PostgreSQL(프로덕션)

---

### C. 구현 복잡도 분석

#### 예상 작업 분량 (5일)

| Phase | 작업 | 시간 | 난이도 |
|-------|------|------|--------|
| 1 | 기본 구조 (라우터, 인증) | 1일 | ⭐ |
| 2 | 디스플레이 관리 API | 1일 | ⭐⭐ |
| 3 | 페어링 시스템 | 1.5일 | ⭐⭐⭐ |
| 4 | 트리거 API | 0.5일 | ⭐ (T-013 활용) |
| 5 | 테스트 | 1일 | ⭐⭐ |

**총 소요시간:** 5일 (테스트 포함)

**예상 코드량:** 500-700줄

---

### D. 기술 선택지

#### 1. 데이터 저장소
```
개발/테스트: 인메모리 Map (가장 빠름)
프로토타입: SQLite (영속성 + 간단함)
프로덕션: PostgreSQL (확장성)
```

**권장:** 인메모리로 시작 → 필요시 마이그레이션

#### 2. Long Polling 구현
```typescript
// GET /api/pair/poll/:sessionId
// 30초 대기 → 승인 시 token 반환 또는 timeout
```

**고려사항:** 간단한 구현, 확장성 낮음 → Phase 2에서 WebSocket 고려

#### 3. JWT 토큰 구조
```typescript
// Bearer 토큰에 포함:
{
  sub: "user-id",
  scopes: ["display:screen:org:line"],
  deviceId?: "...",
  exp: timestamp
}
```

---

### E. 보안 고려사항

#### 인증 & 권한
- ✅ JWT 기반 (기존 구현 재사용)
- ✅ scopes로 세분화된 접근 제어
- ✅ screenId 권한 검증

#### 입력 검증
- ⚠️ Zod 스키마 정의 필수
- ⚠️ 예제: deviceId(UUID), screenId(정규식), jobNo(길이)

#### 레이트 리미팅
- ✅ IP + 사용자 기반 이중 제한
- ✅ 트리거: 초당 10회 (IP), 분당 100회 (사용자)

#### 감시 & 감사
- ⚠️ 모든 API 호출 로깅 필수
- ⚠️ trigger_logs 테이블에 기록 (감시용)
- ⚠️ 권한 실패 시 경고 로그

---

## 📁 산출물 설명

### 1. T-014_아키텍처분석.md (30KB+)
**내용:**
- 1절: 현재 코드베이스 분석 (Express, Socket.IO, 인증, 타입 시스템)
- 2절: 기존 패턴 분석 (에러 응답, 로깅, 레이트 리미팅)
- 3절: T-014 통합 설계 (데이터베이스, API 설계, 서비스 아키텍처)
- 4절: 구현 가이드 (순서, 환경변수, 테스트)

**대상:** 아키텍트, 시니어 개발자

---

### 2. T-014_구현세부가이드.md (25KB+)
**내용:**
- REST API 인증 미들웨어 (Bearer 토큰)
- Zod 검증 스키마 (모든 엔드포인트)
- 에러 응답 표준화
- 레이트 리미팅 세부 설정
- 라우터 구현 예제 (displays, pairing, triggers)
- 데이터베이스 스키마 (SQLite)
- 통합 테스트 예제

**대상:** 구현 담당자, 개발자

---

### 3. T-014_아키텍처분석_요약.md (15KB)
**내용:**
- 5가지 핵심 사항
- 구현 체크리스트
- 파일 구조
- 주의사항
- 성능 목표
- 주요 코드 스니펫

**대상:** 프로젝트 관리자, 빠른 참조 필요 시

---

## 🚀 다음 단계

### Phase 1: 준비 (0.5일)
```bash
# 1. 라우터 파일 구조 생성
mkdir -p server/src/routes
mkdir -p server/src/schemas
mkdir -p server/src/middleware

# 2. 의존성 추가
npm install zod uuid jsonwebtoken express-rate-limit

# 3. 환경변수 설정
# .env 파일 업데이트
```

### Phase 2: 기본 구조 (1일)
```typescript
// 1. expressAuthMiddleware 구현
// 2. Zod 검증 스키마
// 3. 에러 처리 표준화
// 4. 레이트 리미팅 설정
```

### Phase 3-4: 비즈니스 로직 (2.5일)
```typescript
// 1. DisplayService
// 2. PairingService
// 3. 4개 라우터 구현
// 4. Socket.IO 통합 (emitToChannel)
```

### Phase 5: 테스트 (1일)
```typescript
// 1. 단위 테스트
// 2. 통합 테스트 (API + Socket.IO)
// 3. 레이트 리미팅 테스트
// 4. E2E 테스트 (Playwright)
```

---

## 📊 의존성 맵

```
T-014 (이 태스크)
  ├─ T-012 (Socket.IO) ✅ 완료
  │   └─ setupDisplayNamespace()
  │   └─ JWT 검증 (verifyDisplayToken)
  │
  ├─ T-013 (채널 관리) ✅ 완료
  │   └─ emitToChannel() ← 트리거에서 사용
  │   └─ subscribeToChannel()
  │
  └─ 새로운 REST API 레이어
      ├─ Express 라우터 4개
      ├─ 인증 미들웨어
      ├─ Zod 검증
      └─ 데이터 저장소 (선택)
```

---

## ✅ 검증 항목

구현 완료 후 다음을 검증하세요:

- [ ] 모든 엔드포인트가 표준 에러 응답 사용
- [ ] JWT 토큰에 scopes 포함
- [ ] screenId 권한 검증 (display:screenId)
- [ ] 트리거 호출 시 emitToChannel로 메시지 전송
- [ ] 초당 10회, 분당 100회 레이트 리미팅 동작
- [ ] 60초 이상 미갱신 디스플레이 offline 처리
- [ ] 5분 타임아웃 페어링 자동 만료
- [ ] 모든 API 호출 로깅
- [ ] txId 기반 중복 메시지 필터링
- [ ] 동시 100+ 채널 메시지 전송 가능

---

## 📝 주요 고려사항 10가지

1. **screenId 형식:** `screen:orgId:lineId` (정규식 검증)
2. **heartbeat 간격:** 30초 (60초 offline threshold 안전)
3. **페어링 코드:** 6자리 숫자 (0-999999)
4. **JWT 만료:** 10분 (페어링), 필요에 따라 조정
5. **온라인 판정:** 60초 이내 마지막 업데이트 시간
6. **메모리 정리:** 30분+ offline 디스플레이 삭제
7. **txId:** UUID (중복 불가능)
8. **에러 응답:** 항상 `{ ok: false, reason: string }`
9. **레이트 리미팅:** IP 우선, 사용자 보조
10. **감시 로그:** trigger_logs에 모든 트리거 기록

---

## 🎓 학습 포인트

T-014를 구현하면서 다음을 배울 수 있습니다:

1. **Express 라우터 아키텍처**
   - 대규모 애플리케이션 설계
   - 미들웨어 체인

2. **JWT 권한 제어 (RBAC/ABAC)**
   - scopes 기반 세분화
   - 엔드포인트별 검증

3. **레이트 리미팅 전략**
   - IP vs 사용자 기반
   - 엔드포인트별 세분화

4. **실시간 양방향 통신**
   - Socket.IO + REST API 통합
   - 메시지 신뢰성 (idempotency)

5. **백엔드 설계 패턴**
   - 서비스 계층 분리
   - 데이터 저장소 추상화
   - 에러 처리 표준화

---

## 📞 문의 및 수정

분석 문서에서 다음이 필요하면 알려주세요:

- [ ] 특정 엔드포인트 상세 설계
- [ ] 데이터베이스 마이그레이션 스크립트
- [ ] Docker 설정
- [ ] CI/CD 파이프라인
- [ ] 모니터링/알림 설정
- [ ] 성능 테스트 시나리오

---

**분석 완료 날짜:** 2025-10-25
**분석 대상:** T-014 "디스플레이 등록, 페어링 및 트리거 API"
**상태:** ✅ 완료 (3개 상세 문서 작성)
