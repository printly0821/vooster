# Socket.IO 서버 기본 설정 및 JWT 인증

**Task ID:** T-012
**Status:** BACKLOG
**Importance:** MUST
**Complexity:** 6/10
**Urgency:** 10/10
**Dependencies:** None

## Description

### 요구사항
- Socket.IO 서버를 Next.js 프로젝트에 통합하고 WSS 프로토콜로 실시간 양방향 통신 제공
- JWT 기반 클라이언트 인증 구현 브라우저 확장에서 전송한 토큰을 검증하고 연결 허용 거부 결정
- 인증 실패 시 즉시 연결 종료 및 명확한 에러 메시지 반환 로깅
- 로컬 개발 환경을 위한 CORS 설정 및 개발용 토큰 검증 우회 플래그 제공
- 재연결 시나리오 처리 동일 deviceId로 재접속 시 이전 세션 정리 및 새 세션 생성

### 구현 상세
- Socket.IO 4.x 설치 및 Next.js API Route에서 서버 인스턴스 생성 http.Server 업그레이드 허용
- 네임스페이스 /display 사용 클라이언트는 ws://localhost:3000/display 또는 wss://domain.com/display로 연결
- 연결 이벤트 핸들러에서 auth 메시지 대기 5초 타임아웃 내 인증 완료 필수
- JWT 검증은 jose 라이브러리 사용 payload에서 deviceId screenId scopes 추출 및 검증
- 인증 성공 시 socket.data에 deviceId screenId 저장 실패 시 disconnect true 호출
- CORS는 개발 환경에서만 허용 프로덕션은 특정 origin만 허용하도록 환경변수로 제어
- 재연결 시 기존 소켓 찾기 io.of(/display).sockets 순회 후 동일 deviceId 발견 시 강제 disconnect
- 모든 인증 시도는 로그 기록 성공 실패 deviceId screenId IP 타임스탬프 포함

### 의사코드
```pseudo
// src/backend/websocket/server.ts
let io: Server

function initSocketServer(httpServer) {
  io = new Server(httpServer, {
    path: '/socket.io',
    cors: { origin: process.env.NODE_ENV === 'dev' ? '*' : allowedOrigins },
  })

  const displayNs = io.of('/display')

  displayNs.on('connection', async (socket) => {
    let authenticated = false

    // 5초 내 인증 필수
    const timeout = setTimeout(() => {
      if (!authenticated) {
        socket.disconnect(true)
        log('auth_timeout', socket.id)
      }
    }, 5000)

    socket.on('auth', async (data) => {
      clearTimeout(timeout)

      const { token, deviceId, screenId } = data
      const claims = await verifyJWT(token)

      if (!claims || !claims.scopes.includes(`display:${screenId}`)) {
        socket.emit('auth_failed', { reason: 'invalid_token' })
        socket.disconnect(true)
        log('auth_failed', deviceId, screenId)
        return
      }

      // 기존 연결 정리
      const existing = findSocketByDeviceId(displayNs, deviceId)
      if (existing) existing.disconnect(true)

      // 인증 성공
      socket.data.deviceId = deviceId
      socket.data.screenId = screenId
      authenticated = true

      socket.emit('auth_success', { screenId })
      log('auth_success', deviceId, screenId, socket.handshake.address)
    })

    socket.on('disconnect', () => {
      log('disconnected', socket.data.deviceId, socket.data.screenId)
    })
  })

  return io
}

async function verifyJWT(token: string) {
  try {
    const secret = new TextEncoder().encode(process.env.JWT_SECRET)
    const { payload } = await jwtVerify(token, secret)
    return payload
  } catch {
    return null
  }
}

function findSocketByDeviceId(ns, deviceId) {
  for (const [id, socket] of ns.sockets) {
    if (socket.data.deviceId === deviceId) return socket
  }
  return null
}
```

### 테스트 전략
- 단위 테스트 verifyJWT 함수를 유효 토큰과 만료된 토큰 잘못된 서명으로 검증 Vitest 사용
- 통합 테스트 실제 Socket.IO 서버 시작 후 socket.io-client로 연결 시도 인증 성공 실패 타임아웃 케이스 검증
- 재연결 테스트 동일 deviceId로 2번 연결 시 첫 번째 소켓이 강제 disconnect되는지 확인
- 로깅 테스트 모든 auth 이벤트가 로그 파일 또는 콘솔에 기록되는지 확인 민감 정보 마스킹 검증
- E2E Playwright로 브라우저에서 WebSocket 연결 후 인증 성공 메시지 수신 확인

---

**Created:** 2025-10-23T08:00:00.000Z
**Updated:** 2025-10-23T08:00:00.000Z
