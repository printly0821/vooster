# 디스플레이 등록, 페어링 및 트리거 API

**Task ID:** T-014
**Status:** BACKLOG
**Importance:** MUST
**Complexity:** 7/10
**Urgency:** 8/10
**Dependencies:** T-012, T-013

## Description

### 요구사항
- 원격 PC 디스플레이 등록 및 관리 API 구현 브라우저 확장이 서버에 heartbeat로 등록 및 상태 업데이트
- 페어링 시스템 API QR 기반 WeChat 스타일 페어링 구현 PC가 QR 생성하고 스마트폰이 승인
- 트리거 API 스마트폰 바코드 스캔 후 원격 디스플레이에 제작의뢰서 표시
- 입력 검증 Zod 스키마로 모든 요청 본문 검증 및 명확한 에러 응답
- 인증 및 권한 검증 JWT Bearer 토큰으로 사용자 및 디스플레이 권한 확인
- 로깅 및 감사 모든 API 호출을 로그 기록 사용자 액션 타임스탬프 IP 포함

### 구현 상세

**A. 디스플레이 등록 API**
- POST /api/displays/register 엔드포인트 브라우저 확장이 30초마다 heartbeat 전송
- 요청 본문 { deviceId, name, purpose, orgId, lineId } Zod로 검증
- displays 테이블 또는 Redis에 저장 last_seen_at 업데이트 60초 이상 미갱신 시 offline 처리
- 응답 { screenId, status } screenId는 screen:orgId:lineId 형식 자동 생성

**B. 페어링 API (WeChat 스타일)**
- POST /api/pair/qr 호출 시 세션 생성 { sessionId, code 6자리, expiresIn: 300s } 반환
- QR 데이터 형식 JSON.stringify sessionId code wsUrl 포함
- GET /api/pair/poll/:sessionId 폴링 엔드포인트 Long Polling 또는 30초 타임아웃으로 승인 대기
- POST /api/pair/approve 스마트폰이 sessionId와 code 전송하여 승인 처리 JWT 토큰 생성 및 반환
- pair_sessions 테이블에 상태 관리 pending approved expired

**C. 디스플레이 목록 API**
- GET /api/displays 스마트폰이 호출 쿼리 파라미터로 lineId 필터링
- 응답 { displays: [{ screenId, name, purpose, online, lastSeen }] } 배열
- 온라인 디스플레이만 또는 전체 옵션 제공

**D. 트리거 API**
- POST /api/trigger 엔드포인트 screenId와 jobNo를 받아 WebSocket으로 navigate 이벤트 전송
- Zod 검증 JWT 권한 확인 txId 생성 WebSocket 전송 로깅 순서대로 처리
- Rate limiting IP 기반 초당 10회 사용자 기반 분당 100회 제한

### 의사코드
```pseudo
// A. 디스플레이 등록
app.post('/api/displays/register', async (req, res) => {
  const { deviceId, name, purpose, orgId, lineId } = req.body
  const screenId = `screen:${orgId}:${lineId}`

  await db.upsert('displays', {
    device_id: deviceId,
    screen_id: screenId,
    name,
    purpose,
    last_seen_at: new Date(),
    status: 'online',
  })

  return res.json({ screenId, status: 'registered' })
})

// B. 페어링 QR 생성
app.post('/api/pair/qr', async (req, res) => {
  const sessionId = crypto.randomUUID()
  const code = generateCode(6) // 6자리 숫자

  await db.insert('pair_sessions', {
    session_id: sessionId,
    code,
    status: 'pending',
    expires_at: new Date(Date.now() + 300000), // 5분
  })

  const qrData = JSON.stringify({ sessionId, code, wsUrl: process.env.WS_URL })

  return res.json({ sessionId, qrData, expiresIn: 300 })
})

// C. 페어링 폴링
app.get('/api/pair/poll/:sessionId', async (req, res) => {
  const { sessionId } = req.params
  const session = await db.findOne('pair_sessions', { session_id: sessionId })

  if (!session || session.status === 'expired') {
    return res.status(404).json({ ok: false, reason: 'not_found' })
  }

  if (session.status === 'approved') {
    return res.json({ ok: true, token: session.token, screenId: session.screen_id })
  }

  // Long Polling (30초 대기)
  await waitForApproval(sessionId, 30000)
  return res.json({ ok: false, reason: 'timeout' })
})

// D. 페어링 승인
app.post('/api/pair/approve', requireAuth, async (req, res) => {
  const { sessionId, code } = req.body
  const session = await db.findOne('pair_sessions', { session_id: sessionId, code })

  if (!session || session.status !== 'pending') {
    return res.status(400).json({ ok: false, reason: 'invalid_session' })
  }

  // JWT 생성
  const token = await createJWT({ deviceId: session.device_id, scopes: [`display:${session.screen_id}`] })

  await db.update('pair_sessions', { session_id: sessionId }, {
    status: 'approved',
    token,
    approved_by: req.user.id,
  })

  return res.json({ ok: true, token, screenId: session.screen_id })
})

// E. 디스플레이 목록
app.get('/api/displays', requireAuth, async (req, res) => {
  const { lineId } = req.query
  const displays = await db.find('displays', {
    line_id: lineId,
    status: 'online',
    last_seen_at: { $gt: new Date(Date.now() - 60000) }, // 1분 이내
  })

  return res.json({ displays })
})

// F. 트리거
const TriggerSchema = z.object({
  screenId: z.string().regex(/^screen:[a-z0-9-]+:[a-z0-9-]+$/),
  jobNo: z.string().min(1).max(50),
})

app.post('/api/trigger', requireAuth, rateLimiter, async (req, res) => {
  // 1. 입력 검증
  const parsed = TriggerSchema.safeParse(req.body)
  if (!parsed.success) {
    return res.status(400).json({
      ok: false,
      reason: 'validation_error',
      errors: parsed.error.errors,
    })
  }

  const { screenId, jobNo } = parsed.data
  const user = req.user

  // 2. 권한 확인
  if (!user.scopes.includes(`display:${screenId}`)) {
    log('trigger_forbidden', user.id, screenId)
    return res.status(403).json({
      ok: false,
      reason: 'forbidden',
    })
  }

  // 3. txId 생성 및 메시지 생성
  const txId = crypto.randomUUID()
  const url = `${process.env.APP_URL}/orders/${jobNo}`
  const payload = {
    type: 'navigate',
    txId,
    screenId,
    jobNo,
    url,
    ts: Date.now(),
    exp: Date.now() + 60000, // 1분 후 만료
  }

  // 4. WebSocket 전송
  const result = await emitToChannel(screenId, 'navigate', payload)

  // 5. 로깅
  await logTrigger({
    userId: user.id,
    screenId,
    jobNo,
    txId,
    status: result.ok ? 'delivered' : 'missed',
    clientCount: result.clientCount || 0,
    ip: req.ip,
  })

  // 6. 응답
  if (!result.ok) {
    return res.status(503).json({
      ok: false,
      reason: result.reason,
      txId,
    })
  }

  return res.json({
    ok: true,
    txId,
    clientCount: result.clientCount,
  })
})
```

### 테스트 전략
- 단위 테스트 모든 Zod 스키마 검증 유효 무효 경계값 케이스 검증 JWT 생성 검증 로직 테스트
- 디스플레이 등록 테스트 heartbeat 30초마다 전송 시 last_seen_at 업데이트 확인 60초 이상 미갱신 시 offline 전환 확인
- 페어링 플로우 테스트 QR 생성 폴링 승인 전체 플로우를 순차 실행하여 토큰 발급 확인
- 페어링 만료 테스트 5분 경과 후 세션 만료 처리 확인 폴링 시 not_found 반환 확인
- 디스플레이 목록 테스트 lineId 필터링 동작 확인 온라인 오프라인 구분 확인
- 트리거 통합 테스트 Socket.IO 클라이언트 연결 후 POST /api/trigger 호출하여 navigate 이벤트 수신 확인
- 권한 테스트 다른 screenId 접근 시 403 반환 확인
- Rate limiting 테스트 초당 10회 분당 100회 제한 동작 확인
- E2E Playwright로 전체 플로우 PC 확장 QR 표시 스마트폰 승인 바코드 스캔 탭 생성 검증

---

**Created:** 2025-10-23T08:20:00.000Z
**Updated:** 2025-10-23T08:20:00.000Z
