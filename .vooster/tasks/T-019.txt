# E2E 통합 테스트 및 시나리오

**Task ID:** T-019
**Status:** BACKLOG
**Importance:** SHOULD
**Complexity:** 6/10
**Urgency:** 6/10
**Dependencies:** T-012, T-013, T-014, T-015, T-016, T-017

## Description

### 요구사항
- 전체 시스템 플로우를 자동으로 검증하는 E2E 테스트 시나리오 작성 및 실행
- Playwright를 사용하여 브라우저 확장 로드 및 WebSocket 연결 테스트
- 페어링 플로우 테스트 QR 스캔 또는 수동 입력 후 연결 성공 확인
- 트리거 API 호출 및 탭 생성 검증 스마트폰 스캔 시뮬레이션 후 원격 PC 브라우저에 탭 생성 확인
- 재연결 및 에러 시나리오 네트워크 단절 장애 주입 후 자동 복구 확인
- 성능 측정 스캔부터 탭 생성까지 E2E 지연시간 측정 목표 P95 500ms

### 구현 상세
- Playwright 설치 및 설정 playwright.config.ts에 브라우저 옵션 및 확장 로드 경로 설정
- 확장 로드 context.addInitScript로 chrome.storage API 모킹 확장 빌드 후 pathToExtension 지정
- 페어링 테스트 Options 페이지 오픈 QR 스캔 버튼 클릭 모킹된 QR 데이터 주입 연결 상태 변경 확인
- 트리거 테스트 page.request.post로 POST /api/trigger 호출 새 탭 생성 대기 URL 검증
- 재연결 테스트 WebSocket 서버 프로세스 kill 후 재시작 확장이 자동 재연결하는지 확인
- 에러 시나리오 잘못된 토큰 만료된 토큰 존재하지 않는 screenId 로 테스트 적절한 에러 메시지 확인
- 성능 측정 page.waitForNavigation으로 지연시간 측정 후 콘솔 출력 또는 리포트 생성
- 스크린샷 및 비디오 녹화 실패 시 자동 스크린샷 저장 CI 환경에서 아티팩트 업로드

### 의사코드
```pseudo
// tests/e2e/remote-display.spec.ts
import { test, expect } from '@playwright/test'

test.describe('원격 디스플레이 시스템 E2E', () => {
  let extensionId: string

  test.beforeAll(async ({ context }) => {
    // 브라우저 확장 로드
    const pathToExtension = path.join(__dirname, '../../extension/dist')
    context = await chromium.launchPersistentContext('', {
      headless: false,
      args: [
        `--disable-extensions-except=${pathToExtension}`,
        `--load-extension=${pathToExtension}`,
      ],
    })

    // 확장 ID 추출
    const background = context.serviceWorkers()[0]
    extensionId = background.url().split('/')[2]
  })

  test('페어링 플로우', async ({ page }) => {
    // 1. Options 페이지 오픈
    await page.goto(`chrome-extension://${extensionId}/options.html`)

    // 2. QR 스캔 시뮬레이션
    await page.evaluate(() => {
      window.postMessage({
        type: 'qr-scanned',
        data: JSON.stringify({
          org: 'test-org',
          line: 'line-a',
          token: 'mock-jwt-token',
          wsUrl: 'ws://localhost:3000/display',
        }),
      }, '*')
    })

    // 3. 페어링 성공 메시지 확인
    await expect(page.locator('text=페어링 완료')).toBeVisible()

    // 4. 연결 상태 확인
    await expect(page.locator('[data-status="connected"]')).toBeVisible()
  })

  test('트리거 및 탭 생성', async ({ page, request }) => {
    // 1. 트리거 API 호출
    const response = await request.post('http://localhost:3000/api/trigger', {
      headers: {
        'Authorization': 'Bearer mock-jwt-token',
      },
      data: {
        screenId: 'screen:test-org:line-a',
        jobNo: 'J2025-12345',
      },
    })

    const result = await response.json()
    expect(result.ok).toBe(true)
    expect(result.txId).toBeTruthy()

    // 2. 새 탭 생성 대기
    await page.waitForTimeout(500)

    // 3. 새 탭 확인
    const pages = page.context().pages()
    const orderTab = pages.find(p => p.url().includes('/orders/J2025-12345'))
    expect(orderTab).toBeTruthy()
  })

  test('재연결 시나리오', async ({ page }) => {
    // 1. WebSocket 서버 강제 종료 (시뮬레이션)
    // 실제로는 docker-compose stop socketio 등으로 처리

    // 2. 연결 끊김 상태 확인
    await expect(page.locator('[data-status="disconnected"]')).toBeVisible({ timeout: 10000 })

    // 3. 서버 재시작

    // 4. 자동 재연결 확인
    await expect(page.locator('[data-status="connected"]')).toBeVisible({ timeout: 30000 })
  })

  test('중복 방지', async ({ page, request }) => {
    // 1. 동일 jobNo로 2번 트리거
    await request.post('http://localhost:3000/api/trigger', {
      headers: { 'Authorization': 'Bearer mock-jwt-token' },
      data: { screenId: 'screen:test-org:line-a', jobNo: 'J2025-99999' },
    })

    await page.waitForTimeout(100)

    await request.post('http://localhost:3000/api/trigger', {
      headers: { 'Authorization': 'Bearer mock-jwt-token' },
      data: { screenId: 'screen:test-org:line-a', jobNo: 'J2025-99999' },
    })

    // 2. 탭이 1개만 생성되었는지 확인
    const pages = page.context().pages()
    const orderTabs = pages.filter(p => p.url().includes('/orders/J2025-99999'))
    expect(orderTabs.length).toBe(1)
  })

  test('성능 측정', async ({ page, request }) => {
    const startTime = Date.now()

    // 트리거 호출
    await request.post('http://localhost:3000/api/trigger', {
      headers: { 'Authorization': 'Bearer mock-jwt-token' },
      data: { screenId: 'screen:test-org:line-a', jobNo: 'J2025-PERF' },
    })

    // 탭 생성 대기
    await page.waitForURL('**/orders/J2025-PERF')

    const endTime = Date.now()
    const latency = endTime - startTime

    console.log(`E2E 지연시간: ${latency}ms`)
    expect(latency).toBeLessThan(500) // 목표: 500ms 이내
  })
})
```

### 테스트 전략
- 테스트 환경 구성 Docker Compose로 전체 시스템 시작 후 Playwright 실행
- 페어링 테스트 QR 스캔 수동 입력 두 가지 방식 모두 검증
- 트리거 테스트 유효한 요청과 무효한 요청 권한 없는 요청 모두 검증
- 재연결 테스트 서버 강제 종료 후 재시작 시 자동 재연결 확인 최대 재시도 횟수 검증
- 중복 테스트 동일 jobNo 연속 트리거 시 dedupe 동작 확인
- 성능 테스트 P50 P95 P99 지연시간 측정 목표 달성 여부 확인
- CI 통합 GitHub Actions에서 docker-compose up 후 Playwright 실행 스크린샷 아티팩트 업로드

---

**Created:** 2025-10-23T09:10:00.000Z
**Updated:** 2025-10-23T09:10:00.000Z
