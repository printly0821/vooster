{
  "rules": [
    {
      "type": "prd",
      "content": "# 바코드 주문 조회 웹앱 PRD\n\n## 1. 제품 개요\n인쇄 생산 현장에서 카메라로 바코드를 스캔하면 주문번호를 자동 식별하고, REST API로 받아온 주문 상세·썸네일 이미지를 즉시 보여주는 반응형 웹 애플리케이션. 어떠한 기기(러기드 PDA, 스마트폰, 태블릿, PC)에서도 사용 가능하며, 작업 흐름을 끊지 않는 빠른 조회 경험을 제공한다.\n\n## 2. 문제 정의\n1. 주문 정보를 확인하려면 PC 앞으로 이동해야 해 공정이 지연된다.\n2. 썸네일을 찾기 어렵고 출력물이 잘못 인쇄될 위험이 있다.\n3. 여러 주문을 연속 처리할 때 이전 내역 재확인이 번거롭다.\n\n## 3. 목표\n1. 바코드 스캔 후 3초 이내에 주문 상세·이미지를 표시한다.\n2. 출력 오류·오배송률을 20% 이상 감소시킨다.\n3. 최근 스캔 내역 기능으로 반복 조회 시간을 50% 단축한다.\n\n## 4. 대상 사용자 (페르소나)\n| 페르소나 | 목표 | 기기 |\n|---|---|---|\n| 현장 작업자 김라인 | 스캔해 즉시 주문·썸네일 확인, 빠른 진행 | 러기드 PDA, 스마트폰 |\n| 작업 관리자 박매니 | 여러 주문을 연속 스캔·모니터링 | 태블릿, PC |\n| 품질 검사원 이QC | 출력물과 주문 이미지를 대조, 오류 제로 | 스마트폰, 태블릿 |\n\n## 5. 핵심 지표 (Success Metrics)\n1. 스캔→주문표시 평균 시간 ≤ 3초\n2. 최초 배포 1개월 내 일일 활성 사용자(DAU) 30명 달성\n3. 출력물 오류/오배송 건수 20% 감소\n4. 최근 내역 사용 비율 60% 이상\n\n## 6. 주요 기능 요구사항\n### 6.1 MVP 기능\n| ID | 기능 | 설명 |\n|---|---|---|\n| F-01 | 바코드 스캔 | 기기 카메라로 1D/2D 바코드 인식 후 주문번호 추출 |\n| F-02 | 주문 상세 조회 | REST API 호출로 주문명, 수량, 옵션, 상태, 썸네일 URL 수신 |\n| F-03 | 썸네일 그리드 | 주문에 포함된 썸네일 전체를 그리드로 표시 |\n| F-04 | 이미지 슬라이드 뷰어 | 썸네일 클릭 시 좌우 스와이프 확대 보기 |\n| F-05 | 최근 스캔 내역(20건) | 로컬 저장소에 기록, 탭 한 번으로 재조회 |\n| F-06 | 다크 모드 | 현장 조도에 맞춰 자동/수동 전환 |\n\n### 6.2 차후(Phase 2+) 기능\n| ID | 기능 | 설명 |\n|---|---|---|\n| F-07 | 주문 상태 실시간 업데이트 | WebSocket 또는 SSE로 상태 변경 푸시 |\n| F-08 | 오프라인 캐싱 | 네트워크 불안정 시 마지막 주문 데이터 표시 & 재시도 |\n| F-09 | 오류 리포트 | 잘못 인식된 데이터 즉시 신고 & 로그 전송 |\n\n## 7. 사용자 흐름 (고수준)\n1. 사용자가 웹앱 열기 → 카메라 권한 허용\n2. 바코드 조준 → 자동 초점 & 인식\n3. 주문번호 추출 → REST API 호출\n4. 주문 상세·썸네일 그리드 표시(≤3초)\n5. 썸네일 선택 → 슬라이드 뷰어 확인\n6. ‘뒤로’ → 최근 스캔 내역에 기록 → 다음 주문 스캔 반복\n\n## 8. 기술 요구사항\n* 플랫폼: 반응형 웹 (Next.js 15 기반, PWA 지원)\n* API: 사내 주문관리 REST API (GET /orders/{orderNo})\n* 바코드 라이브러리: zxing-js/browser 또는 Dynamsoft Web SDK\n* 이미지 뷰어: Swiper.js + Lazy Loading\n* 로컬 캐싱: IndexedDB(SWR/React-Query offline persistence)\n* 다크 모드: CSS `prefers-color-scheme` + 토글\n\n## 9. 비기능 요구사항\n| 항목 | 목표 |\n|---|---|\n| 성능 | 스캔→표시 ≤3초, Lighthouse Performance ≥90 |\n| 가용성 | 99% 이상 (PWA 오프라인 fallback) |\n| 보안 | HTTPS, 최소 권한 카메라 권한, API 토큰 인증 |\n| 접근성 | WCAG 2.1 AA, 키보드 조작 지원 |\n\n## 10. 출시 범위 & 일정 (MVP)\n| 주 | 마일스톤 |\n|---|---|\n| 1 | 요구사항 확정, 디자인 가이드 |\n| 2–3 | 프론트엔드 개발(스캔·API 연동) |\n| 4 | 썸네일 그리드 & 슬라이드 뷰어 |\n| 5 | 최근 내역, 다크 모드, QA |\n| 6 | 현장 Pilot 배포, 피드백 수집 |\n\n## 11. 리스크 & 완화 전략\n| 리스크 | 영향 | 대응 |\n|---|---|---|\n| 카메라 인식률 저하 | 생산 지연 | 러기드 기기 사양 검증, 라이브러리 AB 테스트 |\n| 네트워크 불안 | 데이터 로딩 실패 | Phase-2 오프라인 캐싱, 재시도 큐 |\n| 사용 거부감 | 도입 실패 | 현장 작업자 조기 테스트 & 피드백 취합 |\n\n## 12. 승인\n제품 책임자: __________________\n일자: __________________________",
      "writedAt": "2025-10-11T01:53:18.305Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n  \n## Tech Stack\n\nNext.js 15, Hono.js, Supabase, TypeScript, TailwindCSS, shadcn, lucide-react, @tanstack/react-query\n\n## Directory Structure\n\n\n/\n├── src/\n│   ├── app/                        # Next.js app router\n│   │   ├── (protected)/            # protected routes group\n│   │   │   └── dashboard/          # dashboard pages\n│   │   ├── api/                    # API routes (Hono integration)\n│   │   ├── login/                  # auth pages\n│   │   ├── signup/                 # auth pages\n│   │   └── example/                # example pages\n│   ├── backend/                    # server-side logic\n│   │   ├── config/                 # backend configuration\n│   │   ├── hono/                   # Hono app setup\n│   │   ├── http/                   # HTTP utilities\n│   │   ├── middleware/             # server middleware\n│   │   └── supabase/               # supabase server client\n│   ├── components/                 # common components\n│   │   └── ui/                     # shadcn/ui components\n│   ├── features/                   # feature-based modules\n│   │   ├── auth/                   # authentication feature\n│   │   │   ├── context/            # auth contexts\n│   │   │   ├── hooks/              # auth hooks\n│   │   │   ├── server/             # auth server logic\n│   │   │   └── types.ts            # auth types\n│   │   └── [featureName]/          \n│   │       ├── backend/            # backend logic\n│   │       ├── components/         # feature components\n│   │       ├── pages/              # feature pages\n│   │       ├── constants.ts        # feature constants\n│   │       ├── types.ts            # feature types\n│   │       └── utils.ts            # feature utils\n│   │       ├── hooks/              # feature hooks\n│   │       └── lib/                # feature utilities\n│   ├── constants/                  # global constants\n│   ├── hooks/                      # common hooks\n│   └── lib/                        # utilities\n│       ├── remote/                 # API client\n│       ├── supabase/               # supabase client setup\n│       └── utils.ts                # shadcn cn utility\n├── public/                         # static assets\n└── supabase/migrations/            # supabase migrations\n\n  ",
      "writedAt": "2025-10-11T01:53:18.305Z"
    },
    {
      "type": "guideline",
      "content": "\n    # Senior Developer Guidelines\n    \n    ## Must\n    \n    - always use client component for all components. (use `use client` directive)\n    - always use promise for page.tsx params props.\n    - use valid picsum.photos stock image for placeholder image\n    \n    ## Library\n    \n    use following libraries for specific functionalities:\n    \n    1. `date-fns`: For efficient date and time handling.\n    2. `ts-pattern`: For clean and type-safe branching logic.\n    3. `@tanstack/react-query`: For server state management.\n    4. `zustand`: For lightweight global state management.\n    5. `react-use`: For commonly needed React hooks.\n    6. `es-toolkit`: For robust utility functions.\n    7. `lucide-react`: For customizable icons.\n    8. `zod`: For schema validation and data integrity.\n    9. `shadcn-ui`: For pre-built accessible UI components.\n    10. `tailwindcss`: For utility-first CSS styling.\n    11. `supabase`: For a backend-as-a-service solution.\n    12. `react-hook-form`: For form validation and state management.\n    \n    ## Directory Structure\n    \n    - src\n    - src/app: Next.js App Routers\n    - src/components/ui: shadcn-ui components\n    - src/constants: Common constants\n    - src/hooks: Common hooks\n    - src/lib: utility functions\n    - src/remote: http client\n    - src/features/[featureName]/components/*: Components for specific feature\n    - src/features/[featureName]/constants/*\n    - src/features/[featureName]/hooks/*\n    - src/features/[featureName]/lib/*\n    - src/features/[featureName]/api.ts: api fetch functions\n    \n    ## Solution Process:\n    \n    1. Rephrase Input: Transform to clear, professional prompt.\n    2. Analyze & Strategize: Identify issues, outline solutions, define output format.\n    3. Develop Solution:\n       - \"As a senior-level developer, I need to [rephrased prompt]. To accomplish this, I need to:\"\n       - List steps numerically.\n       - \"To resolve these steps, I need the following solutions:\"\n       - List solutions with bullet points.\n    4. Validate Solution: Review, refine, test against edge cases.\n    5. Evaluate Progress:\n       - If incomplete: Pause, inform user, await input.\n       - If satisfactory: Proceed to final output.\n    6. Prepare Final Output:\n       - ASCII title\n       - Problem summary and approach\n       - Step-by-step solution with relevant code snippets\n       - Format code changes:\n        ```language:path/to/file\n         // ... existing code ...\n         function exampleFunction() {\n             // Modified or new code here\n         }\n         // ... existing code ...\n         ```\n       - Use appropriate formatting\n       - Describe modifications\n       - Conclude with potential improvements\n    \n    ## Key Mindsets:\n    \n    1. Simplicity\n    2. Readability\n    3. Maintainability\n    4. Testability\n    5. Reusability\n    6. Functional Paradigm\n    7. Pragmatism\n    \n    ## Code Guidelines:\n    \n    1. Early Returns\n    2. Conditional Classes over ternary\n    3. Descriptive Names\n    4. Constants > Functions\n    5. DRY\n    6. Functional & Immutable\n    7. Minimal Changes\n    8. Pure Functions\n    9. Composition over inheritance\n    \n    ## Functional Programming:\n    \n    - Avoid Mutation\n    - Use Map, Filter, Reduce\n    - Currying and Partial Application\n    - Immutability\n    \n    ## Code-Style Guidelines\n    \n    - Use TypeScript for type safety.\n    - Follow the coding standards defined in the ESLint configuration.\n    - Ensure all components are responsive and accessible.\n    - Use Tailwind CSS for styling, adhering to the defined color palette.\n    - When generating code, prioritize TypeScript and React best practices.\n    - Ensure that any new components are reusable and follow the existing design patterns.\n    - Minimize the use of AI generated comments, instead use clearly named variables and functions.\n    - Always validate user inputs and handle errors gracefully.\n    - Use the existing components and pages as a reference for the new components and pages.\n    \n    ## Performance:\n    \n    - Avoid Premature Optimization\n    - Profile Before Optimizing\n    - Optimize Judiciously\n    - Document Optimizations\n    \n    ## Comments & Documentation:\n    \n    - Comment function purpose\n    - Use JSDoc for JS\n    - Document \"why\" not \"what\"\n    \n    ## Function Ordering:\n    \n    - Higher-order functionality first\n    - Group related functions\n    \n    ## Handling Bugs:\n    \n    - Use TODO: and FIXME: comments\n    \n    ## Error Handling:\n    \n    - Use appropriate techniques\n    - Prefer returning errors over exceptions\n    \n    ## Testing:\n    \n    - Unit tests for core functionality\n    - Consider integration and end-to-end tests\n    \n    ## Next.js\n    \n    - you must use promise for page.tsx params props.\n    \n    ## Shadcn-ui\n    \n    - if you need to add new component, please show me the installation instructions. I'll paste it into terminal.\n    - example\n      ```\n      $ npx shadcn@latest add card\n      $ npx shadcn@latest add textarea\n      $ npx shadcn@latest add dialog\n      ```\n    \n    ## Supabase\n    \n    - if you need to add new table, please create migration. I'll paste it into supabase.\n    - do not run supabase locally\n    - store migration query for `.sql` file. in /supabase/migrations/\n    \n    ## Package Manager\n    \n    - use npm as package manager.\n    \n    ## Korean Text\n    \n    - 코드를 생성한 후에 utf-8 기준으로 깨지는 한글이 있는지 확인해주세요. 만약 있다면 수정해주세요.\n    \n    You are a senior full-stack developer, one of those rare 10x devs. Your focus: clean, maintainable, high-quality code.\n    Apply these principles judiciously, considering project and team needs.\n      ",
      "writedAt": "2025-10-11T01:53:18.305Z"
    },
    {
      "type": "design-guide",
      "content": "# 바코드 주문 조회 웹앱 Design Guide\n\n## 1. Overall Mood (전체적인 무드)\n\n현장 작업 환경에서의 **신뢰성과 전문성**을 강조하는 디자인 컨셉을 채택합니다. 작업자들이 빠르고 정확하게 정보를 파악할 수 있도록 **깔끔하고 차분한 분위기**를 조성하며, 높은 신뢰감을 주는 **정보 중심적인 디자인**을 구현합니다. \n\n핵심 키워드:\n- **깔끔함**: 불필요한 장식 요소 제거, 정보 전달에 집중\n- **차분함**: 작업 집중도를 높이는 안정적인 색상과 레이아웃\n- **신뢰감**: 일관성 있는 시각적 위계와 명확한 피드백\n- **효율성**: 빠른 작업 흐름을 지원하는 직관적인 인터페이스\n\n## 2. Reference Service (참조 서비스)\n\n- **Name**: Notion\n- **Description**: 올인원 워크스페이스 및 노트 작성 도구\n- **Design Mood**: 밝고 미니멀하며 정보 위계를 명확하게 보여주는 전문적인 디자인\n- **Primary Color**: #2F3437 (Deep Gray)\n- **Secondary Color**: #37352F (Warm Gray)\n\nNotion의 정보 구조화 방식과 깔끔한 카드 레이아웃을 참조하여, 복잡한 주문 정보를 명확하게 전달할 수 있는 디자인을 구현합니다.\n\n## 3. Color & Gradient (색상 & 그라데이션)\n\n**색상 성향**: Cool 톤, 낮은-중간 채도 (Low-to-Medium Saturation)\n\n### 주요 색상 팔레트\n- **Primary Color**: #1E2A38 (Deep Navy) - 헤더, 주요 버튼\n- **Secondary Color**: #4F6D7A (Steel Blue) - 보조 버튼, 강조 아이콘\n- **Accent Color**: #2ECC71 (Emerald) - 성공 상태, 중요 하이라이트\n- **Background**: #F7F9FB (Ghost White) - 페이지 베이스 배경\n- **Surface**: #FFFFFF (Pure White) - 카드, 모달 배경\n- **Text Primary**: #2B2B2B (Charcoal) - 주요 텍스트\n- **Text Secondary**: #5C6973 (Slate Gray) - 보조 텍스트, 레이블\n- **Error**: #E24C4B (Crimson) - 오류 상태, 경고\n\n### 색상 사용 우선순위\n1. **최우선**: Primary (Deep Navy) - 주요 액션 버튼, 헤더\n2. **중요**: Accent (Emerald) - 스캔 성공, 완료 상태\n3. **보조**: Secondary (Steel Blue) - 보조 버튼, 아이콘\n4. **배경**: Background/Surface - 정보 구조화\n\n**Mood**: 차분하고 전문적인 Cool 톤으로 작업 집중도를 높이며, 낮은 채도로 눈의 피로를 최소화합니다.\n\n## 4. Typography & Font (타이포그래피 & 폰트)\n\n### 폰트 패밀리\n- **한글/영문**: \"Noto Sans KR\", \"Inter\", sans-serif\n- **코드/숫자**: \"JetBrains Mono\", monospace\n\n### 타이포그래피 스케일 (14px-32px)\n- **Heading 1**: Noto Sans KR, 32px, Weight 600 - 페이지 제목\n- **Heading 2**: Noto Sans KR, 24px, Weight 600 - 섹션 제목\n- **Heading 3**: Noto Sans KR, 20px, Weight 600 - 카드 제목\n- **Body Large**: Noto Sans KR, 18px, Weight 400 - 주요 정보\n- **Body**: Noto Sans KR, 16px, Weight 400 - 일반 텍스트\n- **Body Small**: Noto Sans KR, 14px, Weight 400 - 보조 정보\n- **Caption**: Noto Sans KR, 12px, Weight 500 - 레이블, 상태\n\n### 줄 간격 및 자간\n- **Line Height**: 1.5 (본문), 1.3 (제목)\n- **Letter Spacing**: -0.01em (한글), 0em (영문)\n\n## 5. Layout & Structure (레이아웃 & 구조)\n\n### 그리드 시스템\n- **기본 단위**: 8pt Grid System\n- **컨테이너 최대 폭**: 1440px (데스크톱)\n- **모바일**: 100% Fluid Width\n- **패딩**: 16px (모바일), 24px (태블릿), 32px (데스크톱)\n\n### 네비게이션 구조\n**Top Bar 1열 구조** 채택\n- **좌측**: 로고 + 카메라/주문조회 토글 버튼\n- **우측**: 최근 내역, 도움말, 다크모드 토글\n- **높이**: 64px (모바일), 72px (데스크톱)\n\n### 레이아웃 원칙\n1. **수직 공간 최대 활용**: 카메라 뷰와 주문 정보 표시 영역 확보\n2. **일관성**: 모바일-데스크톱 간 동일한 네비게이션 구조\n3. **접근성**: 최소 터치 영역 44×44px 보장\n\n## 6. Visual Style (비주얼 스타일)\n\n### 아이콘 시스템\n- **아이콘 세트**: Lucide React\n- **선 두께**: 1.5px\n- **스타일**: Round Cap\n- **크기**: 16px (Small), 20px (Medium), 24px (Large)\n\n### 이미지 스타일\n- **썸네일**: 1:1 비율, 8px 라운드 모서리\n- **주문 이미지**: 원본 비율 유지, 6px 라운드 모서리\n- **로딩 상태**: Skeleton UI with shimmer effect\n\n### 그림자 시스템\n- **Card Shadow**: 0 1px 3px rgba(0,0,0,0.1), 0 1px 2px rgba(0,0,0,0.06)\n- **Modal Shadow**: 0 20px 25px rgba(0,0,0,0.15), 0 10px 10px rgba(0,0,0,0.04)\n- **Button Hover**: 0 4px 6px rgba(0,0,0,0.1)\n\n### 라운드 모서리\n- **버튼**: 6px\n- **카드**: 8px\n- **모달**: 12px\n- **이미지**: 6px\n\n## 7. UX Guide (UX 가이드)\n\n### 타겟 사용자별 UX 전략\n**전문가 + 초보자 모두 지원하는 Progressive Disclosure 방식**\n\n### 전문가용 (Expert Mode)\n- **즉시 작업 모드**: 앱 실행 시 바로 카메라 화면 표시\n- **최소 UI**: 핵심 기능만 노출, 고급 기능은 숨김\n- **키보드 단축키**: 스페이스바(스캔), ESC(취소), 화살표(이미지 탐색)\n\n### 초보자용 (Beginner Support)\n- **온보딩**: 첫 방문 시 3-4장의 튜토리얼 슬라이드\n- **도움말**: 우상단 '?' 아이콘으로 언제든 접근 가능\n- **시각적 가이드**: 바코드 스캔 영역 표시, 진행 상태 명확한 피드백\n\n### 핵심 UX 원칙\n1. **3초 룰**: 스캔 후 3초 내 결과 표시\n2. **원터치 원칙**: 주요 액션은 1번의 터치로 완료\n3. **피드백 필수**: 모든 액션에 즉각적인 시각/촉각 피드백\n4. **오류 복구**: 명확한 오류 메시지와 해결 방법 제시\n\n## 8. UI Component Guide (UI 컴포넌트 가이드)\n\n### 버튼 (Buttons)\n```\nPrimary Button:\n- 배경: #1E2A38 (Deep Navy)\n- 텍스트: #FFFFFF\n- 높이: 48px (모바일), 44px (데스크톱)\n- 패딩: 16px 24px\n- 라운드: 6px\n\nSecondary Button:\n- 테두리: 1.5px solid #4F6D7A\n- 텍스트: #4F6D7A\n- 배경: transparent\n- hover: 배경 #4F6D7A, 텍스트 #FFFFFF\n\nGhost Button:\n- 텍스트: #4F6D7A\n- 배경: transparent\n- hover: 배경 rgba(79, 109, 122, 0.1)\n```\n\n### 카드 (Cards)\n```\n기본 카드:\n- 배경: #FFFFFF\n- 그림자: Card Shadow\n- 라운드: 8px\n- 패딩: 16px\n- 테두리: 1px solid #E5E7EB\n\n주문 정보 카드:\n- 헤더: 주문번호 + 상태 배지\n- 본문: 주문명, 수량, 옵션 정보\n- 하단: 썸네일 그리드 (최대 4개 미리보기)\n```\n\n### 입력 필드 (Input Fields)\n```\n기본 입력 필드:\n- 높이: 48px\n- 패딩: 12px 16px\n- 테두리: 1.5px solid #D1D5DB\n- 라운드: 6px\n- focus: 테두리 #2ECC71\n\n검색 필드:\n- 좌측 아이콘: Search (20px)\n- placeholder: \"주문번호로 검색...\"\n```\n\n### 모달 (Modals)\n```\n이미지 뷰어 모달:\n- 전체화면 오버레이\n- 배경: rgba(0,0,0,0.9)\n- 좌우 스와이프 지원\n- 상단: 닫기 버튼 + 이미지 인덱스\n- 하단: 썸네일 네비게이션\n\n일반 모달:\n- 중앙 정렬\n- 최대 폭: 480px (모바일에서 90%)\n- 라운드: 12px\n- 패딩: 24px\n```\n\n### 네비게이션 바 (Navigation Bar)\n```\nTop Bar:\n- 높이: 64px (모바일), 72px (데스크톱)\n- 배경: #FFFFFF\n- 하단 테두리: 1px solid #E5E7EB\n- 패딩: 0 16px\n\n좌측 영역:\n- 로고 (32px 높이)\n- 모드 토글 (카메라/검색)\n\n우측 영역:\n- 최근 내역 아이콘\n- 도움말 아이콘\n- 다크모드 토글\n```\n\n### 최근 내역 드로어 (Recent History)\n```\n모바일: Bottom Sheet\n- 하단에서 올라오는 슬라이드\n- 최대 높이: 70vh\n- 드래그 핸들 포함\n\n데스크톱: Side Panel\n- 우측에서 슬라이드\n- 폭: 320px\n- 반투명 오버레이\n```\n\n### 상태 표시 (Status Indicators)\n```\n성공 상태:\n- 색상: #2ECC71\n- 아이콘: Check Circle\n- 진동: 200ms\n\n오류 상태:\n- 색상: #E24C4B\n- 아이콘: X Circle\n- 진동: 300ms (2회)\n\n로딩 상태:\n- Skeleton UI\n- Shimmer 효과\n- 스피너: 20px, #4F6D7A\n```\n\n### 다크 모드 (Dark Mode)\n```\n배경 색상:\n- 페이지: #121212\n- 카드: #1E1E1E\n- 네비게이션: #1F1F1F\n\n텍스트 색상:\n- Primary: #E1E1E1\n- Secondary: #A1A1A1\n\nPrimary 색상 유지: #1E2A38 → 약간 밝게 #2A3A4A\n```\n\n### 접근성 가이드라인\n- **색상 대비**: 최소 4.5:1 (WCAG AA 준수)\n- **터치 영역**: 최소 44×44px\n- **키보드 네비게이션**: 모든 인터랙티브 요소 접근 가능\n- **스크린 리더**: 적절한 aria-label 및 role 속성 사용\n- **모션**: prefers-reduced-motion 미디어 쿼리 지원\n\n### 애니메이션 및 트랜지션\n```\n기본 트랜지션: 200ms ease-in-out\n버튼 hover: 150ms ease\n모달 등장: 300ms ease-out\n이미지 슬라이드: 250ms ease-in-out\n스캔 성공 피드백: 200ms fade-in\n```",
      "writedAt": "2025-10-11T01:53:18.305Z"
    },
    {
      "type": "ia",
      "content": "# 바코드 주문 조회 웹앱 Information Architecture (IA)\n\n## 1. Site Map (사이트맵)\n\n```\n바코드 주문 조회 웹앱\n├── 홈 (카메라 스캔)\n│   ├── 카메라 뷰\n│   ├── 스캔 결과 처리\n│   └── 권한 오류 상태\n├── 주문 상세\n│   ├── 주문 정보 헤더\n│   ├── 주문 메타데이터\n│   ├── 썸네일 그리드\n│   └── 액션 버튼들\n├── 이미지 뷰어 (모달)\n│   ├── 전체 이미지 캐러셀\n│   ├── 썸네일 네비게이터\n│   └── 확대/축소 컨트롤\n├── 최근 스캔 내역\n│   ├── 스캔 내역 목록 (최대 20건)\n│   ├── 재조회 기능\n│   └── 전체 삭제 옵션\n├── 도움말 및 튜토리얼\n│   ├── 온보딩 슬라이드\n│   ├── 사용법 가이드\n│   └── FAQ 링크\n└── 설정\n    ├── 다크 모드 토글\n    ├── 카메라 설정\n    └── 앱 정보\n```\n\n## 2. User Flow (사용자 흐름)\n\n### 주요 작업 1: 바코드 스캔 및 주문 조회\n1. 사용자가 웹앱에 접속한다\n2. 카메라 권한을 허용한다\n3. 바코드를 카메라로 스캔한다\n4. 자동으로 주문번호가 인식된다\n5. API 호출로 주문 상세 정보를 가져온다 (≤3초)\n6. 주문 정보와 썸네일 그리드가 표시된다\n7. 필요시 썸네일을 탭하여 이미지 뷰어로 이동한다\n8. 작업 완료 후 다시 카메라 화면으로 돌아간다\n\n### 주요 작업 2: 최근 내역에서 주문 재조회\n1. 상단 네비게이션의 최근 내역 아이콘을 탭한다\n2. 최근 스캔 내역 드로어/패널이 열린다\n3. 원하는 주문을 선택한다\n4. 해당 주문의 상세 정보가 표시된다\n5. 이미지 확인 후 드로어를 닫는다\n\n### 주요 작업 3: 연속 스캔 작업 (작업 관리자)\n1. 카메라 모드에서 첫 번째 바코드를 스캔한다\n2. 주문 정보를 확인한다\n3. \"다음 스캔\" 버튼을 탭하여 카메라로 자동 복귀한다\n4. 두 번째 바코드를 스캔한다\n5. 이 과정을 반복한다\n6. 필요시 최근 내역에서 이전 주문을 재확인한다\n\n## 3. Navigation Structure (네비게이션 구조)\n\n### 글로벌 네비게이션 바 (GNB)\n- **위치**: 상단 고정\n- **높이**: 64px (모바일), 72px (데스크톱)\n- **좌측 영역**:\n  - 로고/홈 버튼\n  - 카메라/검색 모드 토글\n- **우측 영역**:\n  - 최근 내역 아이콘 (History)\n  - 도움말 아이콘 (Help)\n  - 다크 모드 토글 (Moon/Sun)\n\n### 컨텍스트 네비게이션\n- **주문 상세 화면**: 뒤로가기 버튼, 공유 버튼\n- **이미지 뷰어**: 닫기 버튼, 이전/다음 버튼\n- **최근 내역**: 닫기 버튼, 전체 삭제 버튼\n\n### 하단 네비게이션 (모바일 전용)\n- **스캔 모드**: 큰 스캔 버튼 (FAB 스타일)\n- **주문 상세**: 작업 완료 버튼, 다시 스캔 버튼\n\n## 4. Page Hierarchy (페이지 계층 구조)\n\n```\n/ (Depth 1) - 홈/카메라 스캔\n├── /order/:orderNo (Depth 2) - 주문 상세\n│   └── /order/:orderNo/image/:index (Depth 3) - 이미지 뷰어 (모달)\n├── /recent (Depth 2) - 최근 내역 (드로어/패널)\n├── /help (Depth 2) - 도움말 (모달)\n│   ├── /help/tutorial (Depth 3) - 온보딩 튜토리얼\n│   └── /help/faq (Depth 3) - 자주 묻는 질문\n└── /settings (Depth 2) - 설정 (모달)\n```\n\n## 5. Content Organization (콘텐츠 구성)\n\n| 페이지 | 주요 콘텐츠 요소 | 우선순위 |\n|---|---|---|\n| 홈 (카메라) | 카메라 뷰, 스캔 가이드, 권한 요청, 로딩 상태 | 1 |\n| 주문 상세 | 주문번호, 상태 배지, 고객명, 수량, 옵션, 썸네일 그리드, 액션 버튼 | 1 |\n| 이미지 뷰어 | 전체 이미지, 확대/축소, 좌우 스와이프, 썸네일 네비게이션 | 2 |\n| 최근 내역 | 스캔 날짜/시간, 주문번호, 미리보기 썸네일, 재조회 버튼 | 2 |\n| 도움말 | 튜토리얼 슬라이드, 사용법 설명, FAQ 링크, 문의 정보 | 3 |\n| 설정 | 다크모드 토글, 카메라 설정, 버전 정보, 피드백 링크 | 3 |\n\n## 6. Interaction Patterns (인터랙션 패턴)\n\n### 스캔 및 인식 패턴\n- **자동 초점**: 바코드 영역 감지 시 자동 포커스\n- **시각적 피드백**: 스캔 성공 시 녹색 테두리 + 진동\n- **음성 피드백**: 스캔 성공음 (선택적)\n- **재시도 패턴**: 인식 실패 시 자동 재시도 (3회)\n\n### 이미지 탐색 패턴\n- **썸네일 그리드**: 4열 그리드 (모바일), 6열 그리드 (태블릿/데스크톱)\n- **이미지 뷰어**: 좌우 스와이프, 핀치 줌, 더블 탭 줌\n- **레이지 로딩**: 뷰포트 진입 시 이미지 로드\n- **플레이스홀더**: 스켈레톤 UI + 심머 효과\n\n### 네비게이션 패턴\n- **드로어**: 최근 내역 (모바일에서 하단 시트)\n- **모달**: 이미지 뷰어, 도움말, 설정\n- **토스트**: 성공/오류 메시지 (3초 자동 닫힘)\n- **풀 스크린**: 이미지 뷰어 모드\n\n### 로딩 및 오류 패턴\n- **로딩 상태**: 스켈레톤 UI, 프로그레스 바, 스피너\n- **오류 복구**: 재시도 버튼, 대안 경로 제시\n- **오프라인 상태**: 배너 알림 + 캐시된 데이터 표시\n- **빈 상태**: 일러스트레이션 + 가이드 텍스트\n\n## 7. URL Structure (URL 구조)\n\n### URL 네이밍 규칙\n- **RESTful 구조**: 리소스 중심의 명명\n- **소문자 + 하이픈**: kebab-case 사용\n- **의미있는 경로**: 사용자가 이해하기 쉬운 구조\n\n### URL 맵핑\n```\n/ - 홈 (카메라 스캔)\n/order/:orderNo - 주문 상세\n/recent - 최근 스캔 내역\n/help - 도움말\n/help/tutorial - 온보딩 튜토리얼\n/settings - 설정\n```\n\n### 쿼리 파라미터\n```\n/?camera=true - 카메라 모드 강제 활성화\n/order/:orderNo?from=recent - 최근 내역에서 진입\n/help?step=1 - 특정 튜토리얼 단계\n```\n\n## 8. Component Hierarchy (컴포넌트 계층 구조)\n\n### 글로벌 컴포넌트\n- **Header**: 로고, 네비게이션 아이콘들\n- **Toast**: 알림 메시지 표시\n- **LoadingSpinner**: 전역 로딩 상태\n- **ErrorBoundary**: 오류 처리 래퍼\n\n### 페이지별 컴포넌트\n\n#### 카메라 스캔 페이지\n- **CameraView**: 카메라 스트림 표시\n- **ScanGuide**: 스캔 가이드라인 오버레이\n- **PermissionPrompt**: 카메라 권한 요청\n- **ScanResult**: 스캔 성공/실패 피드백\n\n#### 주문 상세 페이지\n- **OrderHeader**: 주문번호, 상태 배지\n- **OrderMeta**: 고객명, 수량, 옵션 정보\n- **ThumbnailGrid**: 썸네일 이미지 그리드\n- **ActionButtons**: 작업 완료, 다시 스캔 버튼\n\n#### 이미지 뷰어 (모달)\n- **ImageCarousel**: 메인 이미지 캐러셀\n- **ThumbnailNav**: 하단 썸네일 네비게이션\n- **ZoomControls**: 확대/축소 컨트롤\n- **ImageCounter**: 현재 이미지 인덱스\n\n#### 최근 내역 (드로어/패널)\n- **HistoryList**: 스캔 내역 목록\n- **HistoryItem**: 개별 내역 아이템\n- **EmptyState**: 내역 없음 상태\n- **ClearAllButton**: 전체 삭제 버튼\n\n#### 공통 UI 컴포넌트\n- **Button**: Primary, Secondary, Ghost 버튼\n- **Card**: 정보 카드 컴포넌트\n- **Badge**: 상태 표시 배지\n- **Modal**: 범용 모달 컴포넌트\n- **Drawer**: 슬라이드 드로어\n- **BottomSheet**: 모바일 하단 시트\n\n### 컴포넌트 재사용 전략\n- **Atomic Design**: 원자 → 분자 → 유기체 → 템플릿 → 페이지\n- **Props 기반**: 동일 컴포넌트의 다양한 변형 지원\n- **컴포지션 패턴**: 작은 컴포넌트들의 조합으로 복잡한 UI 구성\n- **상태 관리**: 전역 상태(Zustand/Redux) + 로컬 상태(useState) 분리\n\n### 반응형 컴포넌트 전략\n- **모바일 우선**: Mobile-first 반응형 디자인\n- **브레이크포인트**: 640px (모바일), 1024px (태블릿), 1440px (데스크톱)\n- **적응형 레이아웃**: 화면 크기별 최적화된 컴포넌트 구성\n- **터치 최적화**: 44px 최소 터치 영역, 제스처 지원",
      "writedAt": "2025-10-11T01:53:18.305Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-10-11T01:53:18.305Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-10-11T01:53:18.305Z"
    }
  ]
}