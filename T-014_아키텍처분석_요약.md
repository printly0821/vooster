# T-014 아키텍처 분석 - 핵심 요약

## 가장 중요한 5가지

### 1. 기존 코드 활용 ✅

| 항목 | 상태 | 활용 방법 |
|-----|------|---------|
| Socket.IO 서버 | ✅ T-012 완료 | `/display` 네임스페이스 기존 사용 |
| JWT 인증 | ✅ T-012 완료 | `verifyDisplayToken()` 함수 재사용 |
| 채널 관리 | ✅ T-013 완료 | `emitToChannel()` 로 navigate 이벤트 전송 |
| 메시지 idempotency | ✅ T-013 완료 | txId 기반 중복 필터링 자동 적용 |
| 로거/설정 | ✅ 구현됨 | Pino 로거, 환경변수 설정 재사용 |

**핵심:** T-014는 Socket.IO 기반의 REST API 레이어를 추가하는 것!

---

### 2. 새로운 Express REST API 레이어

**현재 상황:** Socket.IO 전용
**필요:** REST API 엔드포인트 4개

```typescript
POST   /api/displays/register      // 디스플레이 heartbeat
GET    /api/displays               // 디스플레이 목록
POST   /api/pair/qr                // QR 생성
GET    /api/pair/poll/:sessionId   // Long Polling
POST   /api/pair/approve           // 승인
POST   /api/trigger                // 트리거 (navigate 전송)
```

**구현 방식:**
- Express 라우터 파일 분리 (`routes/displays.ts`, `routes/pairing.ts`, `routes/triggers.ts`)
- Express 전용 인증 미들웨어 추가 (`expressAuthMiddleware`)
- Zod 스키마로 입력값 검증

---

### 3. 인증 아키텍처

**현재 (Socket.IO 레벨):**
```typescript
socket.on('auth', (payload) => {
  const claims = verifyDisplayToken(token, jwtSecret, screenId);
  // JWT 검증 & scopes 확인
})
```

**필요 (REST API 레벨):**
```typescript
// Bearer 토큰 검증
app.use('/api/', expressAuthMiddleware(jwtSecret));

// 요청 헤더: Authorization: Bearer <JWT>
// 토큰에 포함된 정보:
{
  sub: "user-id",           // 사용자
  scopes: ["display:*"],    // 권한
  deviceId?: "...",         // 선택사항
  screenId?: "..."          // 선택사항
}
```

**권한 검증:**
- screenId 접근 시: scopes에 `display:{screenId}` 포함 확인
- 모든 화면: `display:*` 스코프로 해결

---

### 4. 데이터 저장소 (3가지 선택지)

| 방식 | 용도 | 장점 | 단점 |
|-----|------|------|------|
| **인메모리** | 개발/테스트 | 매우 빠름 | 재시작 시 데이터 손실 |
| **SQLite** | 프로토타입 | 영속성 + 간단함 | 동시성 약함 |
| **PostgreSQL** | 프로덕션 | 확장성 우수 | 셋업 복잡 |

**권장:** 인메모리로 빠르게 개발 → SQLite 테스트 → 프로덕션 PostgreSQL

**필수 테이블:**
```sql
displays          -- deviceId, screenId, lastSeenAt, status
pair_sessions     -- sessionId, code, status, token, expiresAt
trigger_logs      -- txId, screenId, jobNo, userId, status (감시용)
```

---

### 5. 핵심 로직 흐름

#### A. 디스플레이 등록 (30초 heartbeat)
```
1. POST /api/displays/register
2. deviceId, screenId 검증
3. DB에 upsert (lastSeenAt 갱신)
4. 60초 이상 미갱신 → offline 처리
5. 정기적으로(5분) 30분+ offline 삭제
```

#### B. 페어링 (QR 스타일)
```
1. POST /api/pair/qr
   → sessionId, code 생성 & 반환
2. GET /api/pair/poll/:sessionId
   → Long Polling 30초 대기
3. POST /api/pair/approve (스마트폰)
   → code 확인 → JWT 토큰 생성
4. 5분 타임아웃 자동 적용
```

#### C. 트리거 (navigate 이벤트)
```
1. POST /api/trigger (스마트폰)
   ↓
2. 권한 확인 (display:screenId scope)
   ↓
3. txId 생성 & navigate 페이로드 구성
   ↓
4. emitToChannel(io, screenId, 'navigate', payload)
   ↓ Socket.IO 전송
5. 브라우저 확장에서 ACK 수신
```

---

## 실제 구현 체크리스트

### Phase 1: 기본 구조 (1일)
- [ ] Express 라우터 파일 구조 생성
- [ ] expressAuthMiddleware 구현
- [ ] Zod 검증 스키마 정의
- [ ] 표준화된 에러 응답 형식

### Phase 2: 디스플레이 (1일)
- [ ] DisplayService 구현 (인메모리)
- [ ] POST /api/displays/register
- [ ] GET /api/displays
- [ ] 온라인/오프라인 상태 로직

### Phase 3: 페어링 (1-2일)
- [ ] PairingService 구현
- [ ] POST /api/pair/qr
- [ ] GET /api/pair/poll/:sessionId (Long Polling)
- [ ] POST /api/pair/approve

### Phase 4: 트리거 (1일)
- [ ] TriggerService 구현
- [ ] POST /api/trigger
- [ ] emitToChannel 통합
- [ ] 레이트 리미팅 설정

### Phase 5: 테스트 (2-3일)
- [ ] 단위 테스트
- [ ] 통합 테스트 (API + Socket.IO)
- [ ] 레이트 리미팅 테스트
- [ ] E2E 테스트

---

## 파일 구조 (완성)

```
server/src/
├── index.ts                          # (수정) Express + Socket.IO 통합
├── routes/
│   ├── displays.ts                  # NEW: 디스플레이 등록/목록
│   ├── pairing.ts                   # NEW: QR 페어링
│   ├── triggers.ts                  # NEW: 트리거
│   └── channels.ts                  # 기존 (이동 필요)
├── services/
│   ├── displayService.ts            # NEW
│   ├── pairingService.ts            # NEW
│   ├── channelManager.ts            # 기존 (수정 불필요)
│   └── sessionService.ts            # 기존 (수정 불필요)
├── middleware/
│   ├── auth.ts                      # 기존
│   ├── expressAuth.ts               # NEW: REST API 인증
│   └── rateLimiting.ts              # NEW: 세분화된 리미팅
├── schemas/
│   └── validation.ts                # NEW: Zod 스키마
├── types/
│   ├── index.ts                     # 기존 (소형 확장)
│   └── errors.ts                    # NEW: 에러 타입
└── utils/
    ├── config.ts                    # 기존
    └── logger.ts                    # 기존
```

---

## 주의사항 ⚠️

### 1. JWT 스코프 설계
```typescript
// screenId가 screen:orgId:lineId 형식일 때
// 토큰에 포함할 scopes:
["display:screen:orgId:lineId"]  // 특정 화면
["display:*"]                    // 모든 화면 (어드민용)
```

### 2. 레이트 리미팅 우선순위
```
IP 리미팅 먼저 (기본 보호)
  ↓
사용자 리미팅 (세밀한 제어)
```

### 3. 디스플레이 온라인 판정
```typescript
const OFFLINE_THRESHOLD = 60 * 1000;  // 60초 경과 → offline
// heartbeat: 30초마다 (안전 마진 2배)
```

### 4. 페어링 코드 형식
```typescript
// 6자리 숫자 (010203 형식)
const code = String(Math.floor(Math.random() * 1000000))
  .padStart(6, '0');
```

### 5. Socket.IO 네임스페이스 분리
```typescript
// 기존 (모바일-모니터 연결)
io.on('connection', ...)

// 브라우저 확장용 (별도)
io.of('/display').on('connection', ...)
```

---

## 성능 목표

| 항목 | 목표 | 달성 방법 |
|-----|------|---------|
| 트리거 지연시간 | P95 < 100ms | emitToChannel 직접 사용 |
| 디스플레이 조회 | < 50ms | 메모리 캐시 |
| 페어링 응답 | < 200ms | 인메모리 저장소 |
| 동시 처리 | 100+개 채널 | Socket.IO 룸 기반 |
| 메모리 사용 | < 50MB | 정기적인 정리 |

---

## 주요 코드 스니펫

### 트리거 API (가장 중요)
```typescript
router.post('/api/trigger', ipLimiter, userLimiter, async (req, res) => {
  // 1. 검증
  const { screenId, jobNo } = req.body;

  // 2. 권한 확인
  if (!req.user.scopes.includes(`display:${screenId}`)) {
    return res.status(403).json({ ok: false });
  }

  // 3. 메시지 생성 & 전송
  const txId = uuidv4();
  const result = emitToChannel(io, screenId, 'navigate', {
    txId,
    screenId,
    jobNo,
    url: `${APP_URL}/orders/${jobNo}`,
    timestamp: Date.now(),
  });

  // 4. 응답
  res.json({
    ok: result.ok,
    txId,
    clientCount: result.clientCount,
  });
});
```

### 디스플레이 등록
```typescript
router.post('/api/displays/register', displayLimiter, async (req, res) => {
  const { deviceId, name, purpose, orgId, lineId } = req.body;
  const screenId = `screen:${orgId}:${lineId}`;

  // DB upsert
  await displayService.register({ deviceId, screenId, name, purpose, orgId, lineId });

  res.json({ ok: true, screenId, status: 'registered' });
});
```

---

## 참고: T-012, T-013과의 관계

```
T-012 (Socket.IO 기본)
  ├─ /display 네임스페이스
  ├─ JWT 검증 (verifyDisplayToken)
  └─ 5초 인증 타임아웃

T-013 (채널 관리)
  ├─ screenId 채널 구독 (socket.join)
  ├─ emitToChannel (navigate 이벤트 전송)
  ├─ 중복 필터링 (txId)
  └─ ACK 처리

T-014 (REST API) ← 이 문서
  ├─ HTTP 엔드포인트 4개
  ├─ T-012/T-013의 서비스 활용
  ├─ 디스플레이 관리 API
  ├─ 페어링 QR 시스템
  └─ 트리거 API (emitToChannel 호출)
```

---

## 결론

**T-014 구현의 핵심:**
1. T-012, T-013 기반의 **REST API 래퍼** 추가
2. Express 라우터로 **4개 엔드포인트** 구현
3. 기존 Socket.IO 서비스 **재사용** (emitToChannel, verifyDisplayToken 등)
4. 인메모리 저장소로 **빠른 개발** → SQLite 검증 → PostgreSQL 마이그레이션

**구현 시간:** 3-5일 (테스트 포함)

**복잡도:** 7/10 (중상) - 기존 코드가 잘 준비되어 있음

**위험도:** 낮음 - 레이트 리미팅, 권한 검증, 일관된 에러 처리만 주의
