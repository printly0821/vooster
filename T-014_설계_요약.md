# T-014 "디스플레이 등록, 페어링 및 트리거 API" - 설계 완료 요약

## 📌 빠른 참조

### 주요 엔드포인트

| 메서드 | 경로 | 설명 | 인증 | 레이트 제한 |
|--------|------|------|------|-----------|
| POST | `/api/displays/register` | 디스플레이 등록/업데이트 | 선택 | IP: 분당 60회 |
| GET | `/api/displays` | 디스플레이 목록 조회 | 필수 | IP: 분당 300회 |
| POST | `/api/pair/qr` | 페어링 QR 생성 | 선택 | IP: 분당 20회 |
| GET | `/api/pair/poll/:sessionId` | 페어링 폴링 (Long Polling) | 선택 | IP: 분당 20회 |
| POST | `/api/pair/approve` | 페어링 승인 | 필수 | IP: 분당 10회 |
| POST | `/api/trigger` | 트리거 전송 | 필수 | IP: 초당 10회 / 사용자: 분당 100회 |

---

## 🗄️ 데이터베이스 테이블

### displays (현재 디스플레이 상태)
```
필드: id, device_id*, screen_id*, name, purpose, org_id, line_id, status, last_seen_at, created_at, updated_at
인덱스: device_id, screen_id, line_id, status, last_seen_at DESC, (org_id, line_id)
용도: 등록된 모든 디스플레이의 현재 상태 및 온라인/오프라인 상태 추적
```

### pair_sessions (임시 페어링 세션)
```
필드: id, session_id*, code, status, device_id, org_id, line_id, token, approved_by, expires_at, created_at, updated_at
인덱스: session_id, status, expires_at DESC, code
용도: 페어링 프로세스 임시 데이터 (5분 TTL)
정리: 자동 만료 또는 정기 정리
```

### trigger_logs (감시 및 감사 로그)
```
필드: id, tx_id*, user_id, screen_id, job_no, status, client_count, ip_address, user_agent, timestamp
인덱스: tx_id, user_id, screen_id, status, timestamp DESC, (user_id, screen_id)
용도: 모든 트리거 호출 기록 (영구 보관)
보관: 90일 이상 아카이빙 권장
```

---

## 🔐 인증 & 권한

### JWT 토큰 구조 (디스플레이)
```json
{
  "sub": "display:screen:org-id:line-id",
  "type": "display",
  "scopes": ["display:screen:org-id:line-id"],
  "deviceId": "uuid-xxx",
  "iat": 1729858225,
  "exp": 1729858825
}
```

### 필수 미들웨어
1. **expressAuthMiddleware**: Bearer 토큰 검증
2. **rateLimitMiddleware**: 엔드포인트별 세분화된 제한
3. **validationMiddleware**: Zod 스키마 검증

---

## 📊 응답 표준화

### 성공 응답
```typescript
{
  ok: true,
  [data_field]: value,  // screenId, token, displays 등
  message?: string,     // 선택사항
}
```

### 에러 응답
```typescript
{
  ok: false,
  reason: string,       // snake_case (validation_error, forbidden, rate_limit_exceeded 등)
  message: string,      // 사람 친화적 메시지
  errors?: Array<{      // 검증 에러 시에만
    field: string,
    message: string,
  }>,
  retryAfter?: number,  // 레이트 리미팅 시에만
}
```

### HTTP 상태 코드
- **200**: 성공
- **400**: 검증 실패, 유효하지 않은 세션/코드
- **401**: 인증 필요 또는 토큰 무효
- **403**: 권한 부족
- **404**: 리소스 없음
- **409**: 디바이스 충돌
- **410**: 세션/토큰 만료
- **429**: 레이트 리미팅 초과
- **503**: 연결된 클라이언트 없음

---

## ⚡ 성능 목표

| 메트릭 | 목표 | 방법 |
|--------|------|------|
| 응답시간 p95 | <100ms | 인덱스 최적화, 비동기 처리 |
| 동시 연결 | 1000+ | Redis 스토어, 수평 확장 |
| 트리거 지연 | <50ms | 비동기 메시지 큐 |
| DB 쿼리 | <10ms | 인덱스 전략 |

---

## 🔄 상태 관리

### 디스플레이 온라인/오프라인 판정
```
- 온라인: last_seen_at이 60초 이내 (SELECT * WHERE last_seen_at > NOW() - 60s)
- 오프라인: 60초 이상 미갱신 (상태 컬럼 업데이트)
- 자동 정리: 30분+ offline 상태일 때 status='offline'으로 변경
- 아카이브: 90일+ offline 상태일 때 삭제 고려
```

### 페어링 세션 생명주기
```
1. QR 생성 (POST /api/pair/qr)
   - UUID 세션ID 생성
   - 6자리 코드 생성
   - TTL 5분 설정 (expires_at = now + 5분)

2. 폴링 (GET /api/pair/poll/:sessionId) - Long Polling 30초
   - 클라이언트: 30초마다 상태 확인
   - 상태 'pending' 유지 중...
   - 상태 'approved' 되면 토큰 반환

3. 승인 (POST /api/pair/approve)
   - 코드 검증
   - 토큰 생성 (exp: 10분)
   - status='approved'로 변경
   - 데이터베이스 저장

4. 정기 정리 (Cron Job)
   - expires_at < NOW()인 레코드 삭제
   - 5분마다 자동 실행 권장
```

### 트리거 흐름
```
1. 클라이언트: POST /api/trigger (screenId, jobNo)
   ↓
2. 서버:
   - 입력 검증
   - 권한 확인 (display:screenId 스코프)
   - Socket.IO로 메시지 전송 (emitToChannel)
   - txId 기반 중복 검사
   ↓
3. 로그:
   - 즉시 응답 (클라이언트 수 포함)
   - 비동기로 trigger_logs 기록
   ↓
4. 결과:
   - 200: 메시지 전송됨
   - 503: 연결된 클라이언트 없음
   - 429: 레이트 리미팅
```

---

## 📋 구현 체크리스트

### Phase 1: 기본 구조 (1일)
- [ ] Express 라우터 분리 (routes/)
- [ ] expressAuthMiddleware 구현
- [ ] Zod 검증 스키마 (schemas/)
- [ ] 에러 응답 표준화
- [ ] 로깅 설정

### Phase 2: API 구현 (2일)
- [ ] POST /api/displays/register
- [ ] GET /api/displays
- [ ] POST /api/pair/qr
- [ ] GET /api/pair/poll/:sessionId
- [ ] POST /api/pair/approve
- [ ] POST /api/trigger (emitToChannel 통합)

### Phase 3: 데이터 저장소 (1일)
- [ ] IDataStore 인터페이스 정의
- [ ] MemoryStore 구현 (개발/테스트)
- [ ] SqliteStore 구현 (프로토타입)
- [ ] PostgresStore 구현 (프로덕션)

### Phase 4: 레이트 리미팅 & 보안 (0.5일)
- [ ] 엔드포인트별 레이트 리미터
- [ ] Zod 검증 강화
- [ ] SQL 인젝션 방지
- [ ] 정기 정리 작업 (Cron)

### Phase 5: 테스트 (1.5일)
- [ ] 단위 테스트
- [ ] 통합 테스트 (API + Socket.IO)
- [ ] 성능 테스트
- [ ] E2E 테스트

---

## 🔧 파일 구조 (예상)

```
server/src/
├── routes/
│   ├── displays.ts          # POST /api/displays/register, GET /api/displays
│   ├── pairing.ts           # POST /api/pair/qr, GET /api/pair/poll, POST /api/pair/approve
│   └── triggers.ts          # POST /api/trigger
├── middleware/
│   ├── auth.ts              # expressAuthMiddleware (Bearer 토큰)
│   ├── rateLimit.ts         # 엔드포인트별 레이트 리미팅
│   └── validation.ts        # Zod 검증
├── schemas/
│   ├── displays.ts
│   ├── pairing.ts
│   └── triggers.ts
├── services/
│   ├── displayService.ts    # 비즈니스 로직
│   ├── pairingService.ts
│   └── triggerService.ts
├── stores/
│   ├── types.ts             # IDataStore 인터페이스
│   ├── memoryStore.ts
│   ├── sqliteStore.ts
│   └── postgresStore.ts
├── utils/
│   ├── errors.ts            # 에러 응답 헬퍼
│   └── validators.ts        # 정규식 등
└── index.ts                 # Express 앱 설정
```

---

## 🚀 배포 단계

### 1단계: 인메모리 (개발)
```bash
DB_TYPE=memory npm run dev
```

### 2단계: SQLite (테스트)
```bash
DB_TYPE=sqlite DB_PATH=./app.db npm start
```

### 3단계: PostgreSQL (프로덕션)
```bash
DB_TYPE=postgres \
DATABASE_URL=postgresql://user:pass@host:5432/db \
npm start
```

---

## 📚 관련 문서

| 문서 | 내용 |
|------|------|
| `T-014_API_설계.md` | 모든 엔드포인트 상세 설계 + 구현 예제 |
| `T-014_데이터베이스_설계.md` | SQL 쿼리 + 마이그레이션 + 모니터링 |
| `T-014_아키텍처분석.md` | 기존 코드베이스 분석 + 통합 설계 |
| `T-014_구현세부가이드.md` | 코드 예제 + 테스트 시나리오 |

---

## ⚠️ 주의사항

1. **screenId 형식**: `screen:<orgId>:<lineId>` (정규식: `^screen:[a-f0-9-]+:[a-f0-9-]+$`)
2. **heartbeat 간격**: 30초 (60초 offline threshold 안전)
3. **페어링 코드**: 6자리 숫자 (0-999999)
4. **토큰 만료**: 디스플레이 10분, 사용자 1시간
5. **온라인 판정**: 60초 이내 last_seen_at
6. **정기 정리**: 30분+ offline → offline 상태, 90일+ → 삭제
7. **txId**: UUID (중복 불가능, 멱등성 보장)

---

## 🔍 테스트 시나리오

### 1. 디스플레이 등록
```bash
curl -X POST http://localhost:3000/api/displays/register \
  -H "Content-Type: application/json" \
  -d '{
    "deviceId": "550e8400-e29b-41d4-a716-446655440000",
    "name": "Pack Line 1",
    "purpose": "work_instruction",
    "orgId": "org-123",
    "lineId": "line-456"
  }'

# 응답: { ok: true, screenId: "screen:org-123:line-456", status: "registered" }
```

### 2. 페어링 시작
```bash
curl -X POST http://localhost:3000/api/pair/qr

# 응답: { ok: true, sessionId: "uuid...", qrData: "{...}" }
```

### 3. 페어링 폴링
```bash
curl http://localhost:3000/api/pair/poll/550e8400-e29b-41d4-a716-446655440000 \
  --max-time 35

# 30초 대기 후 timeout 또는 token 반환
```

### 4. 페어링 승인 (관리자)
```bash
curl -X POST http://localhost:3000/api/pair/approve \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <admin-jwt>" \
  -d '{
    "sessionId": "550e8400-e29b-41d4-a716-446655440000",
    "code": "123456"
  }'

# 응답: { ok: true, token: "jwt-token...", screenId: "screen:org-123:line-456" }
```

### 5. 트리거 전송
```bash
curl -X POST http://localhost:3000/api/trigger \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer <display-jwt>" \
  -d '{
    "screenId": "screen:org-123:line-456",
    "jobNo": "ORDER-12345",
    "priority": "high"
  }'

# 응답: { ok: true, txId: "uuid...", clientCount: 5, message: "트리거가 전송되었습니다" }
```

---

## 📞 개발팀 연락처

| 역할 | 담당 |
|------|------|
| 아키텍처 | 이 문서 참조 |
| 구현 | T-014_구현세부가이드.md |
| 테스트 | T-014 테스트 계획 |
| 배포 | DEPLOYMENT.md |

---

**설계 완료 날짜:** 2025-10-25
**버전:** 1.0
**상태:** 구현 준비 완료
