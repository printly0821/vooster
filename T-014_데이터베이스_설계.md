# T-014 ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ & SQL ì¿¼ë¦¬ ê°€ì´ë“œ

## ğŸ“Š ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ ê°œìš”

### í…Œì´ë¸” êµ¬ì¡° ë‹¤ì´ì–´ê·¸ë¨

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     displays        â”‚  (í˜„ì¬ ë“±ë¡ëœ ëª¨ë“  ë””ìŠ¤í”Œë ˆì´)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)             â”‚
â”‚ device_id (UK)      â”‚â”€â”€â”
â”‚ screen_id (UK)      â”‚  â”‚
â”‚ name                â”‚  â”‚
â”‚ purpose             â”‚  â”‚
â”‚ org_id              â”‚  â”‚
â”‚ line_id             â”‚  â”‚
â”‚ status              â”‚  â”‚
â”‚ last_seen_at        â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ created_at          â”‚  â”‚  â”‚  pair_sessions       â”‚
â”‚ updated_at          â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚ id (PK)              â”‚
                         â”‚  â”‚ session_id (UK)      â”‚
                         â”‚  â”‚ code                 â”‚
                         â”‚  â”‚ status               â”‚
                         â”œâ”€â”€â”‚ device_id (FK)       â”‚
                         â”‚  â”‚ org_id               â”‚
                         â”‚  â”‚ line_id              â”‚
                         â”‚  â”‚ token                â”‚
                         â”‚  â”‚ approved_by          â”‚
                         â”‚  â”‚ expires_at           â”‚
                         â”‚  â”‚ created_at           â”‚
                         â”‚  â”‚ updated_at           â”‚
                         â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
                         â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                         â”‚  â”‚   trigger_logs       â”‚
                         â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                         â”‚  â”‚ id (PK)              â”‚
                         â”‚  â”‚ tx_id (UK)           â”‚
                         â”‚  â”‚ user_id              â”‚
                         â”œâ”€â”€â”‚ screen_id (FK)       â”‚
                         â”‚  â”‚ job_no               â”‚
                         â”‚  â”‚ status               â”‚
                         â”‚  â”‚ client_count         â”‚
                         â”‚  â”‚ ip_address           â”‚
                         â”‚  â”‚ user_agent           â”‚
                         â”‚  â”‚ timestamp            â”‚
                         â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 1. í…Œì´ë¸”ë³„ ìƒì„¸ SQL

### 1.1 displays í…Œì´ë¸”

#### CREATE TABLE (SQLite)
```sql
-- SQLite ë²„ì „ (ê°œë°œ/í…ŒìŠ¤íŠ¸ìš©)
CREATE TABLE IF NOT EXISTS displays (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  device_id TEXT NOT NULL UNIQUE,
  screen_id TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  purpose TEXT,
  org_id TEXT NOT NULL,
  line_id TEXT NOT NULL,
  status TEXT DEFAULT 'online' CHECK (status IN ('online', 'offline')),
  last_seen_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  user_agent TEXT,
  client_version TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_displays_device_id ON displays(device_id);
CREATE INDEX idx_displays_screen_id ON displays(screen_id);
CREATE INDEX idx_displays_line_id ON displays(line_id);
CREATE INDEX idx_displays_status ON displays(status);
CREATE INDEX idx_displays_last_seen ON displays(last_seen_at DESC);
CREATE INDEX idx_displays_org_line ON displays(org_id, line_id);
```

#### CREATE TABLE (PostgreSQL)
```sql
-- PostgreSQL ë²„ì „ (í”„ë¡œë•ì…˜ìš©)
CREATE TABLE displays (
  id BIGSERIAL PRIMARY KEY,
  device_id VARCHAR(100) NOT NULL UNIQUE,
  screen_id VARCHAR(100) NOT NULL UNIQUE,
  name VARCHAR(100) NOT NULL,
  purpose VARCHAR(255),
  org_id VARCHAR(100) NOT NULL,
  line_id VARCHAR(100) NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'online',
  last_seen_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  user_agent TEXT,
  client_version VARCHAR(50),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  CONSTRAINT check_status CHECK (status IN ('online', 'offline'))
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_displays_device_id ON displays(device_id);
CREATE INDEX idx_displays_screen_id ON displays(screen_id);
CREATE INDEX idx_displays_line_id ON displays(line_id);
CREATE INDEX idx_displays_status ON displays(status);
CREATE INDEX idx_displays_last_seen ON displays(last_seen_at DESC);
CREATE INDEX idx_displays_org_line ON displays(org_id, line_id);

-- íŠ¸ë¦¬ê±° (ìë™ updated_at ì—…ë°ì´íŠ¸)
CREATE OR REPLACE FUNCTION update_displays_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_displays_updated_at
  BEFORE UPDATE ON displays
  FOR EACH ROW
  EXECUTE FUNCTION update_displays_updated_at();
```

#### ì£¼ìš” ì¿¼ë¦¬

```sql
-- 1. ë””ë°”ì´ìŠ¤ ì‹ ê·œ ë“±ë¡
INSERT INTO displays
  (device_id, screen_id, name, purpose, org_id, line_id, status, last_seen_at)
VALUES
  (?, ?, ?, ?, ?, ?, 'online', CURRENT_TIMESTAMP);

-- 2. ê¸°ì¡´ ë””ë°”ì´ìŠ¤ ì—…ë°ì´íŠ¸ (heartbeat)
UPDATE displays
SET
  last_seen_at = CURRENT_TIMESTAMP,
  status = 'online',
  user_agent = ?,
  client_version = ?
WHERE device_id = ?;

-- 3. screenIdë¡œ ë””ìŠ¤í”Œë ˆì´ ì¡°íšŒ
SELECT * FROM displays
WHERE screen_id = ?
LIMIT 1;

-- 4. ë¼ì¸ë³„ ì˜¨ë¼ì¸ ë””ìŠ¤í”Œë ˆì´ ì¡°íšŒ
SELECT * FROM displays
WHERE org_id = ?
  AND line_id = ?
  AND status = 'online'
  AND last_seen_at > datetime('now', '-60 seconds')
ORDER BY last_seen_at DESC;

-- 5. ì˜¤í”„ë¼ì¸ ìƒíƒœë¡œ ë³€ê²½ (30ë¶„ ì´ìƒ ë¯¸ê°±ì‹ )
UPDATE displays
SET status = 'offline'
WHERE last_seen_at < datetime('now', '-30 minutes')
  AND status = 'online';

-- 6. ì˜¤ë˜ëœ ë°ì´í„° ì‚­ì œ (90ì¼+)
DELETE FROM displays
WHERE status = 'offline'
  AND updated_at < datetime('now', '-90 days');

-- 7. í˜ì´ì§€ë„¤ì´ì…˜ ì¡°íšŒ
SELECT * FROM displays
WHERE org_id = ?
ORDER BY last_seen_at DESC
LIMIT ? OFFSET ?;
```

---

### 1.2 pair_sessions í…Œì´ë¸”

#### CREATE TABLE (SQLite)
```sql
CREATE TABLE IF NOT EXISTS pair_sessions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id TEXT NOT NULL UNIQUE,
  code TEXT NOT NULL,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'expired')),
  device_id TEXT,
  org_id TEXT,
  line_id TEXT,
  token TEXT,
  approved_by TEXT,
  approved_at DATETIME,
  expires_at DATETIME NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_pair_sessions_session_id ON pair_sessions(session_id);
CREATE INDEX idx_pair_sessions_status ON pair_sessions(status);
CREATE INDEX idx_pair_sessions_expires_at ON pair_sessions(expires_at DESC);
CREATE INDEX idx_pair_sessions_code ON pair_sessions(code);
```

#### CREATE TABLE (PostgreSQL)
```sql
CREATE TABLE pair_sessions (
  id BIGSERIAL PRIMARY KEY,
  session_id VARCHAR(36) NOT NULL UNIQUE,
  code VARCHAR(6) NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'pending',
  device_id VARCHAR(100),
  org_id VARCHAR(100),
  line_id VARCHAR(100),
  token TEXT,
  approved_by VARCHAR(100),
  approved_at TIMESTAMP,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  CONSTRAINT check_status CHECK (status IN ('pending', 'approved', 'expired'))
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_pair_sessions_session_id ON pair_sessions(session_id);
CREATE INDEX idx_pair_sessions_status ON pair_sessions(status);
CREATE INDEX idx_pair_sessions_expires_at ON pair_sessions(expires_at DESC);
CREATE INDEX idx_pair_sessions_code ON pair_sessions(code);

-- íŠ¸ë¦¬ê±°
CREATE OR REPLACE FUNCTION update_pair_sessions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_pair_sessions_updated_at
  BEFORE UPDATE ON pair_sessions
  FOR EACH ROW
  EXECUTE FUNCTION update_pair_sessions_updated_at();
```

#### ì£¼ìš” ì¿¼ë¦¬

```sql
-- 1. í˜ì–´ë§ ì„¸ì…˜ ìƒì„±
INSERT INTO pair_sessions
  (session_id, code, status, expires_at)
VALUES
  (?, ?, 'pending', datetime('now', '+5 minutes'));

-- 2. ì„¸ì…˜ ìƒíƒœ í™•ì¸
SELECT * FROM pair_sessions
WHERE session_id = ?
  AND expires_at > CURRENT_TIMESTAMP;

-- 3. ì„¸ì…˜ ìŠ¹ì¸ (ì½”ë“œ ê²€ì¦)
UPDATE pair_sessions
SET
  status = 'approved',
  token = ?,
  device_id = ?,
  org_id = ?,
  line_id = ?,
  approved_by = ?,
  approved_at = CURRENT_TIMESTAMP
WHERE session_id = ?
  AND code = ?
  AND status = 'pending'
  AND expires_at > CURRENT_TIMESTAMP;

-- 4. Long Polling (30ì´ˆë§ˆë‹¤ í™•ì¸)
SELECT status, token FROM pair_sessions
WHERE session_id = ?;

-- 5. ë§Œë£Œëœ ì„¸ì…˜ ì •ë¦¬ (ìë™ ì‹¤í–‰)
DELETE FROM pair_sessions
WHERE expires_at < CURRENT_TIMESTAMP;

-- 6. pending ìƒíƒœì¸ ì„¸ì…˜ ì¡°íšŒ (ê´€ë¦¬ìš©)
SELECT COUNT(*) as pending_count
FROM pair_sessions
WHERE status = 'pending'
  AND expires_at > CURRENT_TIMESTAMP;
```

---

### 1.3 trigger_logs í…Œì´ë¸”

#### CREATE TABLE (SQLite)
```sql
CREATE TABLE IF NOT EXISTS trigger_logs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  tx_id TEXT NOT NULL UNIQUE,
  user_id TEXT NOT NULL,
  screen_id TEXT NOT NULL,
  job_no TEXT NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('delivered', 'missed', 'timeout')),
  client_count INTEGER DEFAULT 0,
  ip_address TEXT,
  user_agent TEXT,
  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_trigger_logs_tx_id ON trigger_logs(tx_id);
CREATE INDEX idx_trigger_logs_user_id ON trigger_logs(user_id);
CREATE INDEX idx_trigger_logs_screen_id ON trigger_logs(screen_id);
CREATE INDEX idx_trigger_logs_status ON trigger_logs(status);
CREATE INDEX idx_trigger_logs_timestamp ON trigger_logs(timestamp DESC);
CREATE INDEX idx_trigger_logs_user_screen ON trigger_logs(user_id, screen_id);
```

#### CREATE TABLE (PostgreSQL)
```sql
CREATE TABLE trigger_logs (
  id BIGSERIAL PRIMARY KEY,
  tx_id VARCHAR(36) NOT NULL UNIQUE,
  user_id VARCHAR(100) NOT NULL,
  screen_id VARCHAR(100) NOT NULL,
  job_no VARCHAR(50) NOT NULL,
  status VARCHAR(20) NOT NULL,
  client_count INTEGER DEFAULT 0,
  ip_address VARCHAR(45),
  user_agent TEXT,
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  CONSTRAINT check_status CHECK (status IN ('delivered', 'missed', 'timeout'))
);

-- ì¸ë±ìŠ¤
CREATE INDEX idx_trigger_logs_tx_id ON trigger_logs(tx_id);
CREATE INDEX idx_trigger_logs_user_id ON trigger_logs(user_id);
CREATE INDEX idx_trigger_logs_screen_id ON trigger_logs(screen_id);
CREATE INDEX idx_trigger_logs_status ON trigger_logs(status);
CREATE INDEX idx_trigger_logs_timestamp ON trigger_logs(timestamp DESC);
CREATE INDEX idx_trigger_logs_user_screen ON trigger_logs(user_id, screen_id);
```

#### ì£¼ìš” ì¿¼ë¦¬

```sql
-- 1. íŠ¸ë¦¬ê±° ë¡œê·¸ ê¸°ë¡
INSERT INTO trigger_logs
  (tx_id, user_id, screen_id, job_no, status, client_count, ip_address, user_agent)
VALUES
  (?, ?, ?, ?, 'delivered', ?, ?, ?);

-- 2. ì¤‘ë³µ ë©”ì‹œì§€ í™•ì¸
SELECT COUNT(*) as count FROM trigger_logs
WHERE tx_id = ?
  AND timestamp > datetime('now', '-1 minute');

-- 3. ì‚¬ìš©ìë³„ í˜¸ì¶œ í†µê³„ (ìµœê·¼ 1ì‹œê°„)
SELECT user_id,
       COUNT(*) as total_calls,
       SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered_count
FROM trigger_logs
WHERE timestamp > datetime('now', '-1 hour')
GROUP BY user_id
ORDER BY total_calls DESC;

-- 4. ì‹¤íŒ¨í•œ íŠ¸ë¦¬ê±° ì¡°íšŒ
SELECT * FROM trigger_logs
WHERE status != 'delivered'
  AND timestamp > datetime('now', '-24 hours')
ORDER BY timestamp DESC;

-- 5. í™”ë©´ë³„ í†µê³„
SELECT screen_id,
       COUNT(*) as total,
       AVG(client_count) as avg_clients,
       SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered
FROM trigger_logs
WHERE timestamp > datetime('now', '-7 days')
GROUP BY screen_id
ORDER BY total DESC;

-- 6. ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ… ê²€ì¦ (ë¶„ë‹¹ 100íšŒ)
SELECT COUNT(*) as calls_in_minute
FROM trigger_logs
WHERE user_id = ?
  AND timestamp > datetime('now', '-1 minute');

-- 7. ê°ì‹œ - ì˜¨ë¼ì¸ ìƒíƒœ ì´ì§€ë§Œ íŠ¸ë¦¬ê±° ë¯¸ìˆ˜ì‹ 
SELECT DISTINCT d.screen_id, d.name
FROM displays d
WHERE d.status = 'online'
  AND d.screen_id NOT IN (
    SELECT DISTINCT screen_id FROM trigger_logs
    WHERE timestamp > datetime('now', '-1 hour')
      AND status = 'delivered'
  );

-- 8. ì˜¤ë˜ëœ ë¡œê·¸ ì‚­ì œ (90ì¼+)
DELETE FROM trigger_logs
WHERE timestamp < datetime('now', '-90 days');

-- 9. IPë³„ íŠ¸ë¦¬ê±° í˜¸ì¶œ í†µê³„ (ì˜ì‹¬ í™œë™ íƒì§€)
SELECT ip_address, COUNT(*) as calls
FROM trigger_logs
WHERE timestamp > datetime('now', '-1 hour')
GROUP BY ip_address
ORDER BY calls DESC
LIMIT 10;
```

---

## 2. ì„±ëŠ¥ ìµœì í™” ê°€ì´ë“œ

### 2.1 ì¸ë±ìŠ¤ ì„ íƒ ê¸°ì¤€

#### ë³µí•© ì¸ë±ìŠ¤ì˜ ì¤‘ìš”ì„±
```sql
-- ìì£¼ í•¨ê»˜ ì‚¬ìš©ë˜ëŠ” ì»¬ëŸ¼ ì¡°í•©
-- displays: (org_id, line_id, status)
SELECT * FROM displays
WHERE org_id = ?
  AND line_id = ?
  AND status = 'online';

-- ì´ ê²½ìš° ë‹¤ìŒ ë³µí•© ì¸ë±ìŠ¤ê°€ íš¨ê³¼ì 
CREATE INDEX idx_displays_org_line_status
  ON displays(org_id, line_id, status);
```

#### ì»¤ë²„ë§ ì¸ë±ìŠ¤ (Covering Index)
```sql
-- ì¸ë±ìŠ¤ë§Œìœ¼ë¡œ ì¿¼ë¦¬ ì™„ë£Œ (í…Œì´ë¸” ì ‘ê·¼ ë¶ˆí•„ìš”)
CREATE INDEX idx_displays_status_name
  ON displays(status) INCLUDE (name, last_seen_at);

SELECT name, last_seen_at FROM displays
WHERE status = 'online';  -- ë¹ ë¦„!
```

### 2.2 ì¿¼ë¦¬ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§

#### SQLite
```sql
-- EXPLAIN QUERY PLAN
EXPLAIN QUERY PLAN
SELECT * FROM displays
WHERE org_id = ? AND line_id = ?;

-- ì¶œë ¥ ê²°ê³¼:
-- 0|0|0|SEARCH displays USING idx_displays_org_line (org_id=?, line_id=?)
--        â†‘ ì¢‹ìŒ! (ì¸ë±ìŠ¤ ì‚¬ìš©)
```

#### PostgreSQL
```sql
-- EXPLAIN ANALYZE
EXPLAIN ANALYZE
SELECT * FROM displays
WHERE org_id = ? AND line_id = ?;

-- Seq Scan vs Index Scan í™•ì¸
-- Index Scanì´ ë” íš¨ìœ¨ì  (ì‘ì€ ê²°ê³¼ì…‹)
-- Seq Scanì´ ë” íš¨ìœ¨ì  (í° ê²°ê³¼ì…‹, 10-20% ì´ìƒ)
```

### 2.3 ë°°ì¹˜ ì²˜ë¦¬

```sql
-- ë‚˜ìœ ì˜ˆ (N+1 ì¿¼ë¦¬ ë¬¸ì œ)
const displays = await getDisplays();
for (const display of displays) {
  await logTrigger(display.screenId);  // Në²ˆ ë°˜ë³µ!
}

-- ì¢‹ì€ ì˜ˆ (ë°°ì¹˜ ì‚½ì…)
INSERT INTO trigger_logs
  (tx_id, screen_id, ...)
VALUES
  (?, ?, ?),
  (?, ?, ?),
  (?, ?, ?);  -- í•œ ë²ˆì— ì—¬ëŸ¬ í–‰ ì‚½ì…
```

---

## 3. ë°ì´í„° ì¼ê´€ì„± ì „ëµ

### 3.1 íŠ¸ëœì­ì…˜ ì‚¬ìš©

```typescript
// PostgreSQL íŠ¸ëœì­ì…˜
async function approvePairing(sessionId: string, code: string) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // 1. ì„¸ì…˜ ê²€ì¦
    const sessionResult = await client.query(
      'SELECT * FROM pair_sessions WHERE session_id = $1 FOR UPDATE',
      [sessionId]
    );
    const session = sessionResult.rows[0];

    if (session.code !== code) {
      throw new Error('Invalid code');
    }

    // 2. ë””ìŠ¤í”Œë ˆì´ ë“±ë¡/ì—…ë°ì´íŠ¸
    await client.query(
      'INSERT INTO displays (...) VALUES (...) ON CONFLICT (...) DO UPDATE SET ...',
      [/* ... */]
    );

    // 3. ì„¸ì…˜ ì—…ë°ì´íŠ¸
    await client.query(
      'UPDATE pair_sessions SET status = $1, token = $2 WHERE session_id = $3',
      ['approved', token, sessionId]
    );

    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

### 3.2 ë™ì‹œì„± ì œì–´

```sql
-- PostgreSQL: í–‰ ë ˆë²¨ ì ê¸ˆ
SELECT * FROM pair_sessions
WHERE session_id = ?
FOR UPDATE;  -- ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì´ ì ‘ê·¼ ë¶ˆê°€

-- ë˜ëŠ” SKIP LOCKED (ëŒ€ê¸° ì—†ìŒ)
SELECT * FROM pair_sessions
WHERE status = 'pending'
FOR UPDATE SKIP LOCKED;
```

---

## 4. ë°±ì—… ë° ë³µêµ¬

### 4.1 SQLite ë°±ì—…
```bash
# ê°„ë‹¨í•œ ë³µì‚¬
cp app.db app.db.backup

# ë˜ëŠ” SQL ë¤í”„
sqlite3 app.db ".dump" > backup.sql

# ë³µêµ¬
sqlite3 app.db < backup.sql
```

### 4.2 PostgreSQL ë°±ì—…
```bash
# ì „ì²´ ë°ì´í„°ë² ì´ìŠ¤ ë°±ì—…
pg_dump -U user -d database > backup.sql

# ì••ì¶•
pg_dump -U user -d database | gzip > backup.sql.gz

# ë³µêµ¬
psql -U user -d database < backup.sql
gunzip -c backup.sql.gz | psql -U user -d database
```

---

## 5. ë§ˆì´ê·¸ë ˆì´ì…˜ ìŠ¤í¬ë¦½íŠ¸

### 5.1 SQLite â†’ PostgreSQL ë§ˆì´ê·¸ë ˆì´ì…˜

```typescript
// server/src/migrate.ts

import sqlite3 from 'sqlite3';
import { Pool } from 'pg';

async function migrateDisplays() {
  // SQLite ì½ê¸°
  const sqliteDb = new sqlite3.Database('app.db');
  const displays = await new Promise<any[]>((resolve, reject) => {
    sqliteDb.all('SELECT * FROM displays', (err, rows) => {
      if (err) reject(err);
      else resolve(rows);
    });
  });

  // PostgreSQL ì“°ê¸°
  const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
  });

  try {
    for (const display of displays) {
      await pool.query(
        `INSERT INTO displays
         (device_id, screen_id, name, purpose, org_id, line_id, status, last_seen_at, created_at, updated_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
         ON CONFLICT (device_id) DO UPDATE SET
         name = $3, status = $7, updated_at = $10`,
        [
          display.device_id,
          display.screen_id,
          display.name,
          display.purpose,
          display.org_id,
          display.line_id,
          display.status,
          display.last_seen_at,
          display.created_at,
          display.updated_at,
        ]
      );
    }
    console.log(`âœ… ${displays.length} ë””ìŠ¤í”Œë ˆì´ ë§ˆì´ê·¸ë ˆì´ì…˜ ì™„ë£Œ`);
  } finally {
    sqliteDb.close();
    await pool.end();
  }
}

// ì‹¤í–‰
migrateDisplays().catch(console.error);
```

---

## 6. ëª¨ë‹ˆí„°ë§ ì¿¼ë¦¬

### 6.1 ë°ì´í„°ë² ì´ìŠ¤ ìƒíƒœ

```sql
-- í…Œì´ë¸” í¬ê¸°
SELECT
  name,
  COUNT(*) as row_count
FROM (
  SELECT 'displays' as name FROM displays
  UNION ALL
  SELECT 'pair_sessions' FROM pair_sessions
  UNION ALL
  SELECT 'trigger_logs' FROM trigger_logs
)
GROUP BY name;

-- ì¸ë±ìŠ¤ ì‚¬ìš© í†µê³„ (PostgreSQL)
SELECT
  schemaname,
  tablename,
  indexname,
  idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0  -- ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ì¸ë±ìŠ¤
ORDER BY idx_scan ASC;

-- ëŠë¦° ì¿¼ë¦¬ (PostgreSQL)
SELECT
  query,
  calls,
  total_time,
  mean_time
FROM pg_stat_statements
WHERE mean_time > 10  -- 10ms ì´ìƒ
ORDER BY mean_time DESC
LIMIT 20;
```

### 6.2 ì €ì¥ ê³µê°„ ì‚¬ìš©ë¥ 

```sql
-- SQLite
SELECT page_count * page_size / 1024.0 / 1024.0 as db_size_mb
FROM pragma_page_count(), pragma_page_size();

-- PostgreSQL
SELECT
  schemaname,
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

---

## 7. ì •ê¸° ìœ ì§€ë³´ìˆ˜ ì‘ì—…

### 7.1 ìë™í™”ëœ ì •ë¦¬ (Cron Job)

```bash
# crontab ì„¤ì • (ë§¤ì¼ ìì •)
0 0 * * * /usr/bin/node /path/to/server/cleanup.js

# crontab ì„¤ì • (ì£¼ 1íšŒ, ì¼ìš”ì¼)
0 1 * * 0 /usr/bin/node /path/to/server/backup.js
```

### 7.2 cleanup.js
```typescript
// server/src/cleanup.ts

import { Pool } from 'pg';

const pool = new Pool({ connectionString: process.env.DATABASE_URL });

async function cleanup() {
  try {
    logger.info('ì •ë¦¬ ì‘ì—… ì‹œì‘');

    // 1. ë§Œë£Œëœ í˜ì–´ë§ ì„¸ì…˜ ì‚­ì œ
    const deletedSessions = await pool.query(
      'DELETE FROM pair_sessions WHERE expires_at < NOW()'
    );
    logger.info(`ì‚­ì œëœ í˜ì–´ë§ ì„¸ì…˜: ${deletedSessions.rowCount}`);

    // 2. ì˜¤í”„ë¼ì¸ ìƒíƒœë¡œ ë³€ê²½
    const offlinedCount = await pool.query(
      `UPDATE displays
       SET status = 'offline'
       WHERE last_seen_at < NOW() - INTERVAL '30 minutes'
       AND status = 'online'`
    );
    logger.info(`ì˜¤í”„ë¼ì¸ìœ¼ë¡œ ë³€ê²½: ${offlinedCount.rowCount}`);

    // 3. ì˜¤ë˜ëœ ë¡œê·¸ ì‚­ì œ (90ì¼+)
    const deletedLogs = await pool.query(
      'DELETE FROM trigger_logs WHERE timestamp < NOW() - INTERVAL \'90 days\''
    );
    logger.info(`ì‚­ì œëœ ë¡œê·¸: ${deletedLogs.rowCount}`);

    // 4. VACUUM (PostgreSQL ìµœì í™”)
    await pool.query('VACUUM');

    logger.info('ì •ë¦¬ ì‘ì—… ì™„ë£Œ');
  } catch (error) {
    logger.error('ì •ë¦¬ ì‘ì—… ì‹¤íŒ¨', error);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

cleanup();
```

---

## 8. íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### 8.1 ì„±ëŠ¥ ë¬¸ì œ

```sql
-- ë¬¸ì œ: "ë„ˆë¬´ ë§ì€ ì˜¤í”„ë¼ì¸ ë””ìŠ¤í”Œë ˆì´"
-- ì›ì¸: last_seen_at ì¸ë±ìŠ¤ ë¶€ì¬ ë˜ëŠ” ì¿¼ë¦¬ ìµœì í™” í•„ìš”

-- í•´ê²°: ì¸ë±ìŠ¤ í™•ì¸
EXPLAIN QUERY PLAN
SELECT COUNT(*) FROM displays
WHERE last_seen_at > datetime('now', '-60 seconds');

-- í•„ìš”ì‹œ ì¸ë±ìŠ¤ ì¶”ê°€
CREATE INDEX idx_displays_last_seen ON displays(last_seen_at DESC);
```

### 8.2 ë””ìŠ¤í¬ ìš©ëŸ‰ ë¬¸ì œ

```sql
-- ë¡œê·¸ í…Œì´ë¸”ì´ ë„ˆë¬´ í¬ë©´ ì•„ì¹´ì´ë¹™
CREATE TABLE trigger_logs_archive AS
SELECT * FROM trigger_logs
WHERE timestamp < datetime('now', '-180 days');

DELETE FROM trigger_logs
WHERE timestamp < datetime('now', '-180 days');
```

### 8.3 ì¤‘ë³µ ë°ì´í„°

```sql
-- ì¤‘ë³µ screenId í™•ì¸
SELECT screen_id, COUNT(*) as count
FROM displays
GROUP BY screen_id
HAVING COUNT(*) > 1;

-- ì¤‘ë³µëœ deviceId í™•ì¸
SELECT device_id, COUNT(*) as count
FROM displays
GROUP BY device_id
HAVING COUNT(*) > 1;
```

---

**ì‘ì„± ì™„ë£Œ:** 2025-10-25
**ë²„ì „:** 1.0
