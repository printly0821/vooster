# T-014 데이터베이스 스키마 & SQL 쿼리 가이드

## 📊 데이터베이스 설계 개요

### 테이블 구조 다이어그램

```
┌─────────────────────┐
│     displays        │  (현재 등록된 모든 디스플레이)
├─────────────────────┤
│ id (PK)             │
│ device_id (UK)      │──┐
│ screen_id (UK)      │  │
│ name                │  │
│ purpose             │  │
│ org_id              │  │
│ line_id             │  │
│ status              │  │
│ last_seen_at        │  │  ┌──────────────────────┐
│ created_at          │  │  │  pair_sessions       │
│ updated_at          │  │  ├──────────────────────┤
└─────────────────────┘  │  │ id (PK)              │
                         │  │ session_id (UK)      │
                         │  │ code                 │
                         │  │ status               │
                         ├──│ device_id (FK)       │
                         │  │ org_id               │
                         │  │ line_id              │
                         │  │ token                │
                         │  │ approved_by          │
                         │  │ expires_at           │
                         │  │ created_at           │
                         │  │ updated_at           │
                         │  └──────────────────────┘
                         │
                         │  ┌──────────────────────┐
                         │  │   trigger_logs       │
                         │  ├──────────────────────┤
                         │  │ id (PK)              │
                         │  │ tx_id (UK)           │
                         │  │ user_id              │
                         ├──│ screen_id (FK)       │
                         │  │ job_no               │
                         │  │ status               │
                         │  │ client_count         │
                         │  │ ip_address           │
                         │  │ user_agent           │
                         │  │ timestamp            │
                         │  └──────────────────────┘
```

---

## 1. 테이블별 상세 SQL

### 1.1 displays 테이블

#### CREATE TABLE (SQLite)
```sql
-- SQLite 버전 (개발/테스트용)
CREATE TABLE IF NOT EXISTS displays (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  device_id TEXT NOT NULL UNIQUE,
  screen_id TEXT NOT NULL UNIQUE,
  name TEXT NOT NULL,
  purpose TEXT,
  org_id TEXT NOT NULL,
  line_id TEXT NOT NULL,
  status TEXT DEFAULT 'online' CHECK (status IN ('online', 'offline')),
  last_seen_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  user_agent TEXT,
  client_version TEXT,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스
CREATE INDEX idx_displays_device_id ON displays(device_id);
CREATE INDEX idx_displays_screen_id ON displays(screen_id);
CREATE INDEX idx_displays_line_id ON displays(line_id);
CREATE INDEX idx_displays_status ON displays(status);
CREATE INDEX idx_displays_last_seen ON displays(last_seen_at DESC);
CREATE INDEX idx_displays_org_line ON displays(org_id, line_id);
```

#### CREATE TABLE (PostgreSQL)
```sql
-- PostgreSQL 버전 (프로덕션용)
CREATE TABLE displays (
  id BIGSERIAL PRIMARY KEY,
  device_id VARCHAR(100) NOT NULL UNIQUE,
  screen_id VARCHAR(100) NOT NULL UNIQUE,
  name VARCHAR(100) NOT NULL,
  purpose VARCHAR(255),
  org_id VARCHAR(100) NOT NULL,
  line_id VARCHAR(100) NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'online',
  last_seen_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  user_agent TEXT,
  client_version VARCHAR(50),
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  CONSTRAINT check_status CHECK (status IN ('online', 'offline'))
);

-- 인덱스
CREATE INDEX idx_displays_device_id ON displays(device_id);
CREATE INDEX idx_displays_screen_id ON displays(screen_id);
CREATE INDEX idx_displays_line_id ON displays(line_id);
CREATE INDEX idx_displays_status ON displays(status);
CREATE INDEX idx_displays_last_seen ON displays(last_seen_at DESC);
CREATE INDEX idx_displays_org_line ON displays(org_id, line_id);

-- 트리거 (자동 updated_at 업데이트)
CREATE OR REPLACE FUNCTION update_displays_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_displays_updated_at
  BEFORE UPDATE ON displays
  FOR EACH ROW
  EXECUTE FUNCTION update_displays_updated_at();
```

#### 주요 쿼리

```sql
-- 1. 디바이스 신규 등록
INSERT INTO displays
  (device_id, screen_id, name, purpose, org_id, line_id, status, last_seen_at)
VALUES
  (?, ?, ?, ?, ?, ?, 'online', CURRENT_TIMESTAMP);

-- 2. 기존 디바이스 업데이트 (heartbeat)
UPDATE displays
SET
  last_seen_at = CURRENT_TIMESTAMP,
  status = 'online',
  user_agent = ?,
  client_version = ?
WHERE device_id = ?;

-- 3. screenId로 디스플레이 조회
SELECT * FROM displays
WHERE screen_id = ?
LIMIT 1;

-- 4. 라인별 온라인 디스플레이 조회
SELECT * FROM displays
WHERE org_id = ?
  AND line_id = ?
  AND status = 'online'
  AND last_seen_at > datetime('now', '-60 seconds')
ORDER BY last_seen_at DESC;

-- 5. 오프라인 상태로 변경 (30분 이상 미갱신)
UPDATE displays
SET status = 'offline'
WHERE last_seen_at < datetime('now', '-30 minutes')
  AND status = 'online';

-- 6. 오래된 데이터 삭제 (90일+)
DELETE FROM displays
WHERE status = 'offline'
  AND updated_at < datetime('now', '-90 days');

-- 7. 페이지네이션 조회
SELECT * FROM displays
WHERE org_id = ?
ORDER BY last_seen_at DESC
LIMIT ? OFFSET ?;
```

---

### 1.2 pair_sessions 테이블

#### CREATE TABLE (SQLite)
```sql
CREATE TABLE IF NOT EXISTS pair_sessions (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  session_id TEXT NOT NULL UNIQUE,
  code TEXT NOT NULL,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'expired')),
  device_id TEXT,
  org_id TEXT,
  line_id TEXT,
  token TEXT,
  approved_by TEXT,
  approved_at DATETIME,
  expires_at DATETIME NOT NULL,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스
CREATE INDEX idx_pair_sessions_session_id ON pair_sessions(session_id);
CREATE INDEX idx_pair_sessions_status ON pair_sessions(status);
CREATE INDEX idx_pair_sessions_expires_at ON pair_sessions(expires_at DESC);
CREATE INDEX idx_pair_sessions_code ON pair_sessions(code);
```

#### CREATE TABLE (PostgreSQL)
```sql
CREATE TABLE pair_sessions (
  id BIGSERIAL PRIMARY KEY,
  session_id VARCHAR(36) NOT NULL UNIQUE,
  code VARCHAR(6) NOT NULL,
  status VARCHAR(20) NOT NULL DEFAULT 'pending',
  device_id VARCHAR(100),
  org_id VARCHAR(100),
  line_id VARCHAR(100),
  token TEXT,
  approved_by VARCHAR(100),
  approved_at TIMESTAMP,
  expires_at TIMESTAMP NOT NULL,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  CONSTRAINT check_status CHECK (status IN ('pending', 'approved', 'expired'))
);

-- 인덱스
CREATE INDEX idx_pair_sessions_session_id ON pair_sessions(session_id);
CREATE INDEX idx_pair_sessions_status ON pair_sessions(status);
CREATE INDEX idx_pair_sessions_expires_at ON pair_sessions(expires_at DESC);
CREATE INDEX idx_pair_sessions_code ON pair_sessions(code);

-- 트리거
CREATE OR REPLACE FUNCTION update_pair_sessions_updated_at()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = CURRENT_TIMESTAMP;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_pair_sessions_updated_at
  BEFORE UPDATE ON pair_sessions
  FOR EACH ROW
  EXECUTE FUNCTION update_pair_sessions_updated_at();
```

#### 주요 쿼리

```sql
-- 1. 페어링 세션 생성
INSERT INTO pair_sessions
  (session_id, code, status, expires_at)
VALUES
  (?, ?, 'pending', datetime('now', '+5 minutes'));

-- 2. 세션 상태 확인
SELECT * FROM pair_sessions
WHERE session_id = ?
  AND expires_at > CURRENT_TIMESTAMP;

-- 3. 세션 승인 (코드 검증)
UPDATE pair_sessions
SET
  status = 'approved',
  token = ?,
  device_id = ?,
  org_id = ?,
  line_id = ?,
  approved_by = ?,
  approved_at = CURRENT_TIMESTAMP
WHERE session_id = ?
  AND code = ?
  AND status = 'pending'
  AND expires_at > CURRENT_TIMESTAMP;

-- 4. Long Polling (30초마다 확인)
SELECT status, token FROM pair_sessions
WHERE session_id = ?;

-- 5. 만료된 세션 정리 (자동 실행)
DELETE FROM pair_sessions
WHERE expires_at < CURRENT_TIMESTAMP;

-- 6. pending 상태인 세션 조회 (관리용)
SELECT COUNT(*) as pending_count
FROM pair_sessions
WHERE status = 'pending'
  AND expires_at > CURRENT_TIMESTAMP;
```

---

### 1.3 trigger_logs 테이블

#### CREATE TABLE (SQLite)
```sql
CREATE TABLE IF NOT EXISTS trigger_logs (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  tx_id TEXT NOT NULL UNIQUE,
  user_id TEXT NOT NULL,
  screen_id TEXT NOT NULL,
  job_no TEXT NOT NULL,
  status TEXT NOT NULL CHECK (status IN ('delivered', 'missed', 'timeout')),
  client_count INTEGER DEFAULT 0,
  ip_address TEXT,
  user_agent TEXT,
  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
);

-- 인덱스
CREATE INDEX idx_trigger_logs_tx_id ON trigger_logs(tx_id);
CREATE INDEX idx_trigger_logs_user_id ON trigger_logs(user_id);
CREATE INDEX idx_trigger_logs_screen_id ON trigger_logs(screen_id);
CREATE INDEX idx_trigger_logs_status ON trigger_logs(status);
CREATE INDEX idx_trigger_logs_timestamp ON trigger_logs(timestamp DESC);
CREATE INDEX idx_trigger_logs_user_screen ON trigger_logs(user_id, screen_id);
```

#### CREATE TABLE (PostgreSQL)
```sql
CREATE TABLE trigger_logs (
  id BIGSERIAL PRIMARY KEY,
  tx_id VARCHAR(36) NOT NULL UNIQUE,
  user_id VARCHAR(100) NOT NULL,
  screen_id VARCHAR(100) NOT NULL,
  job_no VARCHAR(50) NOT NULL,
  status VARCHAR(20) NOT NULL,
  client_count INTEGER DEFAULT 0,
  ip_address VARCHAR(45),
  user_agent TEXT,
  timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,

  CONSTRAINT check_status CHECK (status IN ('delivered', 'missed', 'timeout'))
);

-- 인덱스
CREATE INDEX idx_trigger_logs_tx_id ON trigger_logs(tx_id);
CREATE INDEX idx_trigger_logs_user_id ON trigger_logs(user_id);
CREATE INDEX idx_trigger_logs_screen_id ON trigger_logs(screen_id);
CREATE INDEX idx_trigger_logs_status ON trigger_logs(status);
CREATE INDEX idx_trigger_logs_timestamp ON trigger_logs(timestamp DESC);
CREATE INDEX idx_trigger_logs_user_screen ON trigger_logs(user_id, screen_id);
```

#### 주요 쿼리

```sql
-- 1. 트리거 로그 기록
INSERT INTO trigger_logs
  (tx_id, user_id, screen_id, job_no, status, client_count, ip_address, user_agent)
VALUES
  (?, ?, ?, ?, 'delivered', ?, ?, ?);

-- 2. 중복 메시지 확인
SELECT COUNT(*) as count FROM trigger_logs
WHERE tx_id = ?
  AND timestamp > datetime('now', '-1 minute');

-- 3. 사용자별 호출 통계 (최근 1시간)
SELECT user_id,
       COUNT(*) as total_calls,
       SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered_count
FROM trigger_logs
WHERE timestamp > datetime('now', '-1 hour')
GROUP BY user_id
ORDER BY total_calls DESC;

-- 4. 실패한 트리거 조회
SELECT * FROM trigger_logs
WHERE status != 'delivered'
  AND timestamp > datetime('now', '-24 hours')
ORDER BY timestamp DESC;

-- 5. 화면별 통계
SELECT screen_id,
       COUNT(*) as total,
       AVG(client_count) as avg_clients,
       SUM(CASE WHEN status = 'delivered' THEN 1 ELSE 0 END) as delivered
FROM trigger_logs
WHERE timestamp > datetime('now', '-7 days')
GROUP BY screen_id
ORDER BY total DESC;

-- 6. 레이트 리미팅 검증 (분당 100회)
SELECT COUNT(*) as calls_in_minute
FROM trigger_logs
WHERE user_id = ?
  AND timestamp > datetime('now', '-1 minute');

-- 7. 감시 - 온라인 상태 이지만 트리거 미수신
SELECT DISTINCT d.screen_id, d.name
FROM displays d
WHERE d.status = 'online'
  AND d.screen_id NOT IN (
    SELECT DISTINCT screen_id FROM trigger_logs
    WHERE timestamp > datetime('now', '-1 hour')
      AND status = 'delivered'
  );

-- 8. 오래된 로그 삭제 (90일+)
DELETE FROM trigger_logs
WHERE timestamp < datetime('now', '-90 days');

-- 9. IP별 트리거 호출 통계 (의심 활동 탐지)
SELECT ip_address, COUNT(*) as calls
FROM trigger_logs
WHERE timestamp > datetime('now', '-1 hour')
GROUP BY ip_address
ORDER BY calls DESC
LIMIT 10;
```

---

## 2. 성능 최적화 가이드

### 2.1 인덱스 선택 기준

#### 복합 인덱스의 중요성
```sql
-- 자주 함께 사용되는 컬럼 조합
-- displays: (org_id, line_id, status)
SELECT * FROM displays
WHERE org_id = ?
  AND line_id = ?
  AND status = 'online';

-- 이 경우 다음 복합 인덱스가 효과적
CREATE INDEX idx_displays_org_line_status
  ON displays(org_id, line_id, status);
```

#### 커버링 인덱스 (Covering Index)
```sql
-- 인덱스만으로 쿼리 완료 (테이블 접근 불필요)
CREATE INDEX idx_displays_status_name
  ON displays(status) INCLUDE (name, last_seen_at);

SELECT name, last_seen_at FROM displays
WHERE status = 'online';  -- 빠름!
```

### 2.2 쿼리 성능 모니터링

#### SQLite
```sql
-- EXPLAIN QUERY PLAN
EXPLAIN QUERY PLAN
SELECT * FROM displays
WHERE org_id = ? AND line_id = ?;

-- 출력 결과:
-- 0|0|0|SEARCH displays USING idx_displays_org_line (org_id=?, line_id=?)
--        ↑ 좋음! (인덱스 사용)
```

#### PostgreSQL
```sql
-- EXPLAIN ANALYZE
EXPLAIN ANALYZE
SELECT * FROM displays
WHERE org_id = ? AND line_id = ?;

-- Seq Scan vs Index Scan 확인
-- Index Scan이 더 효율적 (작은 결과셋)
-- Seq Scan이 더 효율적 (큰 결과셋, 10-20% 이상)
```

### 2.3 배치 처리

```sql
-- 나쁜 예 (N+1 쿼리 문제)
const displays = await getDisplays();
for (const display of displays) {
  await logTrigger(display.screenId);  // N번 반복!
}

-- 좋은 예 (배치 삽입)
INSERT INTO trigger_logs
  (tx_id, screen_id, ...)
VALUES
  (?, ?, ?),
  (?, ?, ?),
  (?, ?, ?);  -- 한 번에 여러 행 삽입
```

---

## 3. 데이터 일관성 전략

### 3.1 트랜잭션 사용

```typescript
// PostgreSQL 트랜잭션
async function approvePairing(sessionId: string, code: string) {
  const client = await pool.connect();
  try {
    await client.query('BEGIN');

    // 1. 세션 검증
    const sessionResult = await client.query(
      'SELECT * FROM pair_sessions WHERE session_id = $1 FOR UPDATE',
      [sessionId]
    );
    const session = sessionResult.rows[0];

    if (session.code !== code) {
      throw new Error('Invalid code');
    }

    // 2. 디스플레이 등록/업데이트
    await client.query(
      'INSERT INTO displays (...) VALUES (...) ON CONFLICT (...) DO UPDATE SET ...',
      [/* ... */]
    );

    // 3. 세션 업데이트
    await client.query(
      'UPDATE pair_sessions SET status = $1, token = $2 WHERE session_id = $3',
      ['approved', token, sessionId]
    );

    await client.query('COMMIT');
  } catch (error) {
    await client.query('ROLLBACK');
    throw error;
  } finally {
    client.release();
  }
}
```

### 3.2 동시성 제어

```sql
-- PostgreSQL: 행 레벨 잠금
SELECT * FROM pair_sessions
WHERE session_id = ?
FOR UPDATE;  -- 다른 트랜잭션이 접근 불가

-- 또는 SKIP LOCKED (대기 없음)
SELECT * FROM pair_sessions
WHERE status = 'pending'
FOR UPDATE SKIP LOCKED;
```

---

## 4. 백업 및 복구

### 4.1 SQLite 백업
```bash
# 간단한 복사
cp app.db app.db.backup

# 또는 SQL 덤프
sqlite3 app.db ".dump" > backup.sql

# 복구
sqlite3 app.db < backup.sql
```

### 4.2 PostgreSQL 백업
```bash
# 전체 데이터베이스 백업
pg_dump -U user -d database > backup.sql

# 압축
pg_dump -U user -d database | gzip > backup.sql.gz

# 복구
psql -U user -d database < backup.sql
gunzip -c backup.sql.gz | psql -U user -d database
```

---

## 5. 마이그레이션 스크립트

### 5.1 SQLite → PostgreSQL 마이그레이션

```typescript
// server/src/migrate.ts

import sqlite3 from 'sqlite3';
import { Pool } from 'pg';

async function migrateDisplays() {
  // SQLite 읽기
  const sqliteDb = new sqlite3.Database('app.db');
  const displays = await new Promise<any[]>((resolve, reject) => {
    sqliteDb.all('SELECT * FROM displays', (err, rows) => {
      if (err) reject(err);
      else resolve(rows);
    });
  });

  // PostgreSQL 쓰기
  const pool = new Pool({
    connectionString: process.env.DATABASE_URL,
  });

  try {
    for (const display of displays) {
      await pool.query(
        `INSERT INTO displays
         (device_id, screen_id, name, purpose, org_id, line_id, status, last_seen_at, created_at, updated_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
         ON CONFLICT (device_id) DO UPDATE SET
         name = $3, status = $7, updated_at = $10`,
        [
          display.device_id,
          display.screen_id,
          display.name,
          display.purpose,
          display.org_id,
          display.line_id,
          display.status,
          display.last_seen_at,
          display.created_at,
          display.updated_at,
        ]
      );
    }
    console.log(`✅ ${displays.length} 디스플레이 마이그레이션 완료`);
  } finally {
    sqliteDb.close();
    await pool.end();
  }
}

// 실행
migrateDisplays().catch(console.error);
```

---

## 6. 모니터링 쿼리

### 6.1 데이터베이스 상태

```sql
-- 테이블 크기
SELECT
  name,
  COUNT(*) as row_count
FROM (
  SELECT 'displays' as name FROM displays
  UNION ALL
  SELECT 'pair_sessions' FROM pair_sessions
  UNION ALL
  SELECT 'trigger_logs' FROM trigger_logs
)
GROUP BY name;

-- 인덱스 사용 통계 (PostgreSQL)
SELECT
  schemaname,
  tablename,
  indexname,
  idx_scan
FROM pg_stat_user_indexes
WHERE idx_scan = 0  -- 사용되지 않는 인덱스
ORDER BY idx_scan ASC;

-- 느린 쿼리 (PostgreSQL)
SELECT
  query,
  calls,
  total_time,
  mean_time
FROM pg_stat_statements
WHERE mean_time > 10  -- 10ms 이상
ORDER BY mean_time DESC
LIMIT 20;
```

### 6.2 저장 공간 사용률

```sql
-- SQLite
SELECT page_count * page_size / 1024.0 / 1024.0 as db_size_mb
FROM pragma_page_count(), pragma_page_size();

-- PostgreSQL
SELECT
  schemaname,
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) as size
FROM pg_tables
WHERE schemaname NOT IN ('pg_catalog', 'information_schema')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

---

## 7. 정기 유지보수 작업

### 7.1 자동화된 정리 (Cron Job)

```bash
# crontab 설정 (매일 자정)
0 0 * * * /usr/bin/node /path/to/server/cleanup.js

# crontab 설정 (주 1회, 일요일)
0 1 * * 0 /usr/bin/node /path/to/server/backup.js
```

### 7.2 cleanup.js
```typescript
// server/src/cleanup.ts

import { Pool } from 'pg';

const pool = new Pool({ connectionString: process.env.DATABASE_URL });

async function cleanup() {
  try {
    logger.info('정리 작업 시작');

    // 1. 만료된 페어링 세션 삭제
    const deletedSessions = await pool.query(
      'DELETE FROM pair_sessions WHERE expires_at < NOW()'
    );
    logger.info(`삭제된 페어링 세션: ${deletedSessions.rowCount}`);

    // 2. 오프라인 상태로 변경
    const offlinedCount = await pool.query(
      `UPDATE displays
       SET status = 'offline'
       WHERE last_seen_at < NOW() - INTERVAL '30 minutes'
       AND status = 'online'`
    );
    logger.info(`오프라인으로 변경: ${offlinedCount.rowCount}`);

    // 3. 오래된 로그 삭제 (90일+)
    const deletedLogs = await pool.query(
      'DELETE FROM trigger_logs WHERE timestamp < NOW() - INTERVAL \'90 days\''
    );
    logger.info(`삭제된 로그: ${deletedLogs.rowCount}`);

    // 4. VACUUM (PostgreSQL 최적화)
    await pool.query('VACUUM');

    logger.info('정리 작업 완료');
  } catch (error) {
    logger.error('정리 작업 실패', error);
    process.exit(1);
  } finally {
    await pool.end();
  }
}

cleanup();
```

---

## 8. 트러블슈팅

### 8.1 성능 문제

```sql
-- 문제: "너무 많은 오프라인 디스플레이"
-- 원인: last_seen_at 인덱스 부재 또는 쿼리 최적화 필요

-- 해결: 인덱스 확인
EXPLAIN QUERY PLAN
SELECT COUNT(*) FROM displays
WHERE last_seen_at > datetime('now', '-60 seconds');

-- 필요시 인덱스 추가
CREATE INDEX idx_displays_last_seen ON displays(last_seen_at DESC);
```

### 8.2 디스크 용량 문제

```sql
-- 로그 테이블이 너무 크면 아카이빙
CREATE TABLE trigger_logs_archive AS
SELECT * FROM trigger_logs
WHERE timestamp < datetime('now', '-180 days');

DELETE FROM trigger_logs
WHERE timestamp < datetime('now', '-180 days');
```

### 8.3 중복 데이터

```sql
-- 중복 screenId 확인
SELECT screen_id, COUNT(*) as count
FROM displays
GROUP BY screen_id
HAVING COUNT(*) > 1;

-- 중복된 deviceId 확인
SELECT device_id, COUNT(*) as count
FROM displays
GROUP BY device_id
HAVING COUNT(*) > 1;
```

---

**작성 완료:** 2025-10-25
**버전:** 1.0
