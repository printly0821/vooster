# T-014 "디스플레이 등록, 페어링 및 트리거 API" 아키텍처 분석

## 목차
1. [현재 코드베이스 분석](#1-현재-코드베이스-분석)
2. [기존 패턴 및 아키텍처](#2-기존-패턴-및-아키텍처)
3. [T-014 통합 설계](#3-t-014-통합-설계)
4. [구현 가이드](#4-구현-가이드)

---

## 1. 현재 코드베이스 분석

### 1.1 Express 라우터 패턴

#### 현재 엔드포인트 구조
```typescript
// server/src/index.ts

// 레이트 리밋 설정 (전역)
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,  // 15분
  max: 100,                   // 요청 제한
  message: '너무 많은 요청을 보냈습니다...'
});
app.use(limiter);

// 기존 엔드포인트들
app.get('/health', ...)
app.get('/status', ...)
app.get('/api/channels/:screenId', ...)
```

**현황:**
- 레이트 리밋: 전역으로 15분 기준 100개 요청 제한 (일괄 적용)
- JWT 인증: Socket.IO 레벨에서만 구현 (REST API 레벨 아님)
- 라우터 구조: 간단한 단일 파일 구조 (확장 필요)

**T-014 통합 시 필요사항:**
- Express 라우터 파일 분리 필요
  ```
  server/src/routes/
    ├── displays.ts      // POST /api/displays/register, GET /api/displays
    ├── pairing.ts       // POST /api/pair/qr, GET /api/pair/poll/:sessionId, POST /api/pair/approve
    ├── triggers.ts      // POST /api/trigger
    └── channels.ts      // GET /api/channels/:screenId (기존)
  ```
- REST API 레벨의 JWT 인증 미들웨어 필요
- 엔드포인트별 세분화된 레이트 리밋 필요

---

### 1.2 인증 미들웨어 분석

#### 현재 JWT 검증 방식

```typescript
// server/src/middleware/auth.ts

// 1. Socket.IO 레벨 인증
export function authMiddleware(jwtSecret: string) {
  return (socket: Socket, next: (err?: Error) => void) => {
    const token = socket.handshake.auth?.token || socket.handshake.headers['x-auth-token'];
    const decoded = jwt.verify(token as string, jwtSecret) as JWTPayload;
    socket.data.user = {
      id: decoded.sub,
      role: decoded.role,
    };
    next();
  };
}

// 2. 디스플레이 토큰 검증 (Socket.IO 특화)
export function verifyDisplayToken(
  token: string,
  jwtSecret: string,
  requiredScreenId: string
): DisplayAuthClaims | null {
  const decoded = jwt.verify(token, jwtSecret) as DisplayAuthClaims;
  const requiredScope = `display:${requiredScreenId}`;
  const hasRequiredScope = decoded.scopes?.includes(requiredScope);

  if (!hasRequiredScope) {
    return null;  // 권한 없음
  }

  return decoded;
}
```

**현황:**
- Socket.IO 중심의 인증만 구현
- 토큰 타입: JWTPayload (사용자 역할 기반)
- 권한 스코프: `display:screenId` 형식으로 세분화
- 검증 위치: 소켓 연결 핸드셰이크 시점

**T-014 REST API 필요 사항:**
```typescript
// 새로운 Express 미들웨어 필요
export function expressAuthMiddleware(jwtSecret: string) {
  return (req: Request, res: Response, next: NextFunction) => {
    const token = req.headers.authorization?.split(' ')[1];  // Bearer token
    if (!token) {
      return res.status(401).json({ ok: false, reason: 'unauthorized' });
    }

    try {
      const decoded = jwt.verify(token, jwtSecret) as DisplayAuthClaims;
      req.user = {
        id: decoded.sub,
        scopes: decoded.scopes,
        deviceId: decoded.deviceId,
      };
      next();
    } catch (error) {
      return res.status(401).json({ ok: false, reason: 'invalid_token' });
    }
  };
}
```

---

### 1.3 Socket.IO 통합 분석

#### 기존 구현 (T-012, T-013 완료)

```typescript
// server/src/index.ts
const io = new SocketIOServer(server, {
  cors: {
    origin: config.corsOrigins,
    credentials: true,
  },
  transports: ['websocket', 'polling'],
  pingInterval: 25000,
  pingTimeout: 60000,
});

// /display 네임스페이스 설정
setupDisplayNamespace(io);

// server/src/events/displayHandlers.ts
export function setupDisplayNamespace(io: Server): void {
  const displayNamespace: Namespace = io.of('/display');

  displayNamespace.on('connection', (socket: Socket) => {
    // 5초 인증 타임아웃
    let authTimeout = setTimeout(() => {
      if (!socket.data.deviceId) {
        socket.disconnect(true);
      }
    }, 5000);

    socket.on('auth', (payload: DisplayClientPayload) => {
      clearTimeout(authTimeout);
      handleDisplayAuth(io, socket, payload);  // JWT 검증 & 채널 구독
    });
  });
}
```

#### 채널 관리 (T-013 완료)

```typescript
// server/src/services/channelManager.ts

// 메시지 브로드캐스트 (T-014에서 사용할 핵심 함수)
export function emitToChannel(
  io: Server,
  screenId: string,
  eventType: string,
  payload: any
): EmitResult {
  // 중복 txId 필터링 (idempotency)
  if (isDuplicateTx(txId)) {
    return { ok: false, reason: 'duplicate' };
  }

  // /display 네임스페이스에서 채널 룸 조회
  const displayNs: Namespace = io.of('/display');
  const room = displayNs.adapter.rooms.get(screenId);

  // 클라이언트 확인 및 메시지 전송
  if (!room || room.size === 0) {
    return { ok: false, reason: 'no_clients' };
  }

  displayNs.to(screenId).emit(eventType, payload);
  return { ok: true, txId, clientCount: room.size };
}

// 채널 상태 조회
export function getChannelStatus(io: Server, screenId: string): ChannelStatus {
  const displayNs = io.of('/display');
  const room = displayNs.adapter.rooms.get(screenId);
  return {
    screenId,
    connected: room ? room.size : 0,
    online: connected > 0,
  };
}
```

**T-014 "트리거 API"에서 활용 가능:**
- `emitToChannel(io, screenId, 'navigate', payload)` 호출
- txId 기반 중복 필터링 자동 적용
- ACK 이벤트 처리 자동 등록 (channelManager 내)

---

### 1.4 현재 타입 시스템

```typescript
// server/src/types/index.ts

// 디스플레이 인증 클레임
export interface DisplayAuthClaims {
  sub: string;                        // 사용자 ID
  deviceId: string;                   // 디바이스 고유 ID
  screenId: string;                   // 화면 ID
  scopes: string[];                   // 권한 ['display:screen-1']
  iat: number;                        // 발급 시간
  exp: number;                        // 만료 시간
}

// 소켓 저장 데이터
export interface DisplaySocketData {
  deviceId: string;                   // 디바이스 ID
  screenId: string;                   // 화면 ID
  authenticatedAt: number;            // 인증 시간
}

// 채널 상태
export interface ChannelStatus {
  screenId: string;
  connected: number;
  online: boolean;
}

// 메시지 전송 결과
export interface EmitResult {
  ok: boolean;
  txId?: string;
  clientCount?: number;
  reason?: 'duplicate' | 'no_clients' | 'error';
}
```

---

## 2. 기존 패턴 및 아키텍처

### 2.1 에러 응답 형식

**현재 Socket.IO 패턴:**
```typescript
// displayHandlers.ts
socket.emit('auth_failed', { reason: 'invalid_payload' });
socket.emit('auth_success', { screenId });
socket.emit('auth_timeout', { reason: 'authentication_timeout' });
```

**T-014에서 필요한 REST API 에러 형식:**
```typescript
// 성공
{ ok: true, ...data }

// 실패 (일관된 형식)
{
  ok: false,
  reason: 'validation_error' | 'unauthorized' | 'forbidden' | 'not_found' | 'internal_error',
  errors?: [{ field, message }],
  txId?: string  // 추적용
}
```

### 2.2 로깅 전략

**현재 로거 설정:**
```typescript
// server/src/utils/logger.ts
export const logger = createLogger('info');  // Pino 기반

// 사용 예
logger.info('디스플레이 클라이언트 인증 성공: deviceId=%s, screenId=%s, socketId=%s, userId=%s, ip=%s',
  deviceId, screenId, socket.id, claims.sub, socket.handshake.address);
```

**T-014에서 필요한 로깅:**
```typescript
// 디스플레이 등록
logger.info('displays.register: deviceId=%s, screenId=%s, orgId=%s, lineId=%s, ip=%s, userId=%s',
  deviceId, screenId, orgId, lineId, req.ip, req.user.id);

// 페어링 요청
logger.info('pairing.qr_created: sessionId=%s, userId=%s, ip=%s, code=%s',
  sessionId, req.user.id, req.ip, code);

// 트리거 발행
logger.info('trigger.sent: txId=%s, screenId=%s, jobNo=%s, userId=%s, ip=%s, clientCount=%d',
  txId, screenId, jobNo, req.user.id, req.ip, clientCount);

// 감사 로그 (중요)
logger.warn('trigger.forbidden: userId=%s, screenId=%s, ip=%s (권한 없음)',
  req.user.id, screenId, req.ip);
```

---

### 2.3 레이트 리미팅 전략

**현재 설정:**
```typescript
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,  // 일괄 제한
});
app.use(limiter);  // 모든 엔드포인트에 적용
```

**T-014 요구사항:**
```
트리거 API (/api/trigger):
- IP 기반: 초당 10회
- 사용자 기반: 분당 100회

디스플레이 등록 (/api/displays/register):
- IP 기반: 분당 60회 (heartbeat 30초마다)

페어링 (/api/pair/*):
- IP 기반: 분당 20회
```

**필요한 구현:**
```typescript
// 엔드포인트별 세분화된 리미터
const triggerLimiter = rateLimit({
  windowMs: 1000,      // 1초
  max: 10,             // IP당 10회
  skip: (req) => req.user?.role === 'admin',  // 어드민 제외 가능
});

const triggerUserLimiter = rateLimit({
  windowMs: 60 * 1000,  // 1분
  max: 100,             // 사용자당 100회
  keyGenerator: (req) => req.user?.id || req.ip,  // 사용자 ID로 그룹화
});

app.post('/api/trigger', triggerLimiter, triggerUserLimiter, triggerHandler);
```

---

## 3. T-014 통합 설계

### 3.1 데이터베이스 요구사항

#### 선택지 분석

T-014는 다음과 같은 저장소 옵션을 제공합니다:

**Option A: 인메모리 저장소 (개발용)**
```typescript
// server/src/stores/displayStore.ts
class DisplayStore {
  private displays = new Map<string, Display>();

  register(display: Display): void {
    this.displays.set(display.deviceId, display);
  }

  getByScreenId(screenId: string): Display | undefined {
    return Array.from(this.displays.values()).find(d => d.screenId === screenId);
  }

  getByLineId(lineId: string): Display[] {
    return Array.from(this.displays.values()).filter(d => d.lineId === lineId);
  }
}
```

**Option B: SQLite (파일 기반, 프로토타입/소규모)**
```typescript
// 필요 라이브러리: sqlite3, better-sqlite3
// schema
CREATE TABLE displays (
  id INTEGER PRIMARY KEY,
  device_id TEXT UNIQUE NOT NULL,
  screen_id TEXT NOT NULL,
  name TEXT,
  purpose TEXT,
  org_id TEXT,
  line_id TEXT,
  last_seen_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
  status TEXT DEFAULT 'online',  -- 'online' | 'offline'
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_screen_id ON displays(screen_id);
CREATE INDEX idx_line_id ON displays(line_id);
CREATE INDEX idx_last_seen_at ON displays(last_seen_at);

CREATE TABLE pair_sessions (
  id INTEGER PRIMARY KEY,
  session_id TEXT UNIQUE NOT NULL,
  code TEXT NOT NULL,
  status TEXT DEFAULT 'pending',  -- 'pending' | 'approved' | 'expired'
  expires_at TIMESTAMP NOT NULL,
  token TEXT,
  approved_by TEXT,
  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE INDEX idx_session_id ON pair_sessions(session_id);
CREATE INDEX idx_expires_at ON pair_sessions(expires_at);
```

**Option C: PostgreSQL (프로덕션)**
```sql
-- 권장하되, T-014에서는 Option A 또는 B로 시작
-- 이유: 의존성 최소화, 빠른 배포
```

**권장사항:**
1. **개발/테스트**: Option A (인메모리) - 가장 빠른 개발
2. **프로토타입**: Option B (SQLite) - 영속성 필요 시
3. **프로덕션**: Option C (PostgreSQL) - 확장성, 동시성

---

### 3.2 Express 라우터 구조 설계

```typescript
// server/src/index.ts (수정)
import express from 'express';
import { displayRoutes } from './routes/displays';
import { pairingRoutes } from './routes/pairing';
import { triggerRoutes } from './routes/triggers';
import { expressAuthMiddleware } from './middleware/auth';

const app = express();

// 미들웨어
app.use(helmet());
app.use(cors({ origin: config.corsOrigins, credentials: true }));
app.use(express.json());
app.use((req, _res, next) => {
  customLogger.debug('%s %s', req.method, req.path);
  next();
});

// 기본 글로벌 레이트 리밋 (선택적)
const globalLimiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 1000,  // 매우 허용적
});
app.use(globalLimiter);

// 헬스체크 (인증 없음)
app.get('/health', ...)
app.get('/status', ...)
app.get('/api/channels/:screenId', ...)

// JWT 인증 미들웨어 적용
app.use('/api/', expressAuthMiddleware(config.jwtSecret));

// 라우터 등록
app.use('/api/displays', displayRoutes);
app.use('/api/pair', pairingRoutes);
app.use('/api/trigger', triggerRoutes);
```

---

### 3.3 API 엔드포인트 설계

#### A. 디스플레이 등록 API

```typescript
// server/src/routes/displays.ts
import express, { Request, Response } from 'express';
import { z } from 'zod';
import { logger } from '../utils/logger';
import { displayService } from '../services/displayService';
import { emitToChannel } from '../services/channelManager';

const router = express.Router();

// 검증 스키마
const RegisterDisplaySchema = z.object({
  deviceId: z.string().uuid(),      // UUID 형식
  name: z.string().min(1).max(100),
  purpose: z.string().min(1).max(200),
  orgId: z.string().min(1).max(50),
  lineId: z.string().min(1).max(50),
});

type RegisterDisplayRequest = z.infer<typeof RegisterDisplaySchema>;

/**
 * POST /api/displays/register
 * 브라우저 확장이 자신을 등록 (heartbeat 30초마다)
 */
router.post('/register', async (req: Request, res: Response) => {
  try {
    // 1. 입력 검증
    const parsed = RegisterDisplaySchema.safeParse(req.body);
    if (!parsed.success) {
      logger.warn('displays.register.validation_error: errors=%s, ip=%s',
        JSON.stringify(parsed.error.errors), req.ip);
      return res.status(400).json({
        ok: false,
        reason: 'validation_error',
        errors: parsed.error.errors,
      });
    }

    const { deviceId, name, purpose, orgId, lineId } = parsed.data;
    const screenId = `screen:${orgId}:${lineId}`;

    // 2. 디스플레이 등록/업데이트
    const result = await displayService.register({
      deviceId,
      screenId,
      name,
      purpose,
      orgId,
      lineId,
    });

    // 3. 로깅
    logger.info('displays.register.success: deviceId=%s, screenId=%s, name=%s, ip=%s',
      deviceId, screenId, name, req.ip);

    // 4. 응답
    res.json({
      ok: true,
      screenId,
      status: 'registered',
    });
  } catch (error) {
    logger.error('displays.register.error: error=%s, ip=%s',
      (error as Error).message, req.ip);
    res.status(500).json({
      ok: false,
      reason: 'internal_error',
    });
  }
});

export const displayRoutes = router;
```

**레이트 리미팅:**
```typescript
// 분당 60회 (30초마다 heartbeat)
const displayLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 60,
  keyGenerator: (req) => req.body.deviceId || req.ip,
  skip: (req) => !req.body.deviceId,  // deviceId 없으면 체크 안함
});

router.post('/register', displayLimiter, async (req, res) => { ... });
```

#### B. 페어링 API

```typescript
// server/src/routes/pairing.ts
import express, { Request, Response } from 'express';
import { z } from 'zod';
import { pairingService } from '../services/pairingService';
import { logger } from '../utils/logger';

const router = express.Router();

/**
 * POST /api/pair/qr
 * PC에서 QR 생성 요청 (사용자 인증 필수)
 */
router.post('/qr', async (req: Request, res: Response) => {
  try {
    const userId = req.user?.id || 'anonymous';

    // 1. 세션 생성
    const session = pairingService.createSession(userId);

    // 2. QR 데이터 생성
    const qrData = JSON.stringify({
      sessionId: session.sessionId,
      code: session.code,
      wsUrl: process.env.WS_URL,
    });

    // 3. 로깅
    logger.info('pairing.qr_created: sessionId=%s, userId=%s, ip=%s',
      session.sessionId, userId, req.ip);

    // 4. 응답
    res.json({
      ok: true,
      sessionId: session.sessionId,
      code: session.code,
      qrData,
      expiresIn: 300,  // 5분
    });
  } catch (error) {
    logger.error('pairing.qr.error: error=%s, ip=%s',
      (error as Error).message, req.ip);
    res.status(500).json({ ok: false, reason: 'internal_error' });
  }
});

/**
 * GET /api/pair/poll/:sessionId
 * Long Polling - 승인 대기 (사용자 미인증 허용)
 */
router.get('/poll/:sessionId', async (req: Request, res: Response) => {
  const { sessionId } = req.params;
  const timeout = 30 * 1000;  // 30초

  try {
    // 1. 세션 조회
    const session = pairingService.getSession(sessionId);
    if (!session) {
      logger.warn('pairing.poll.session_not_found: sessionId=%s, ip=%s',
        sessionId, req.ip);
      return res.status(404).json({
        ok: false,
        reason: 'session_not_found',
      });
    }

    // 2. 이미 승인됨
    if (session.status === 'approved') {
      return res.json({
        ok: true,
        token: session.token,
        screenId: session.screenId,
      });
    }

    // 3. Long Polling 대기
    const approved = await waitForApproval(sessionId, timeout);
    if (approved) {
      const approvedSession = pairingService.getSession(sessionId)!;
      return res.json({
        ok: true,
        token: approvedSession.token,
        screenId: approvedSession.screenId,
      });
    }

    // 4. 타임아웃
    return res.status(408).json({
      ok: false,
      reason: 'timeout',
    });
  } catch (error) {
    logger.error('pairing.poll.error: sessionId=%s, error=%s, ip=%s',
      sessionId, (error as Error).message, req.ip);
    res.status(500).json({ ok: false, reason: 'internal_error' });
  }
});

/**
 * POST /api/pair/approve
 * 스마트폰에서 QR 스캔 후 승인 (사용자 인증 필수)
 */
router.post('/approve', async (req: Request, res: Response) => {
  const ApproveSchema = z.object({
    sessionId: z.string().uuid(),
    code: z.string().length(6),
  });

  try {
    const parsed = ApproveSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({
        ok: false,
        reason: 'validation_error',
        errors: parsed.error.errors,
      });
    }

    const { sessionId, code } = parsed.data;
    const userId = req.user?.id || 'anonymous';

    // 1. 세션 확인
    const session = pairingService.getSession(sessionId);
    if (!session || session.code !== code) {
      logger.warn('pairing.approve.invalid: sessionId=%s, userId=%s, ip=%s',
        sessionId, userId, req.ip);
      return res.status(400).json({
        ok: false,
        reason: 'invalid_code',
      });
    }

    // 2. JWT 생성
    const token = pairingService.generateToken(session, userId);

    // 3. 세션 승인
    pairingService.approve(sessionId, token, userId);

    // 4. 로깅
    logger.info('pairing.approved: sessionId=%s, approvedBy=%s, ip=%s',
      sessionId, userId, req.ip);

    // 5. 응답
    res.json({
      ok: true,
      token,
      screenId: session.screenId,
    });
  } catch (error) {
    logger.error('pairing.approve.error: error=%s, ip=%s',
      (error as Error).message, req.ip);
    res.status(500).json({ ok: false, reason: 'internal_error' });
  }
});

export const pairingRoutes = router;
```

#### C. 디스플레이 목록 API

```typescript
// GET /api/displays?lineId=line-1&onlineOnly=true
router.get('/', async (req: Request, res: Response) => {
  try {
    const { lineId, onlineOnly = true } = req.query;

    // 1. 검증
    if (lineId && typeof lineId !== 'string') {
      return res.status(400).json({
        ok: false,
        reason: 'validation_error',
      });
    }

    // 2. 조회
    const displays = await displayService.getDisplays({
      lineId: lineId as string | undefined,
      onlineOnly: onlineOnly === 'true',
    });

    // 3. 응답
    res.json({
      ok: true,
      displays: displays.map(d => ({
        screenId: d.screenId,
        name: d.name,
        purpose: d.purpose,
        online: d.status === 'online',
        lastSeen: new Date(d.lastSeenAt).toISOString(),
      })),
    });
  } catch (error) {
    logger.error('displays.list.error: error=%s', (error as Error).message);
    res.status(500).json({ ok: false, reason: 'internal_error' });
  }
});
```

#### D. 트리거 API

```typescript
// server/src/routes/triggers.ts
import express, { Request, Response } from 'express';
import { z } from 'zod';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '../utils/logger';
import { emitToChannel } from '../services/channelManager';
import rateLimit from 'express-rate-limit';

const router = express.Router();

// 스키마
const TriggerSchema = z.object({
  screenId: z.string().regex(/^screen:[a-z0-9-]+:[a-z0-9-]+$/),
  jobNo: z.string().min(1).max(50),
});

// IP 기반 레이트 리미팅: 초당 10회
const ipLimiter = rateLimit({
  windowMs: 1000,
  max: 10,
  message: '너무 많은 요청입니다 (IP당 초당 10회)',
});

// 사용자 기반 레이트 리미팅: 분당 100회
const userLimiter = rateLimit({
  windowMs: 60 * 1000,
  max: 100,
  keyGenerator: (req) => req.user?.id || req.ip,
  message: '너무 많은 요청입니다 (분당 100회)',
  skip: (req) => !req.user?.id,  // 사용자 ID 없으면 체크 안함
});

/**
 * POST /api/trigger
 * 스마트폰에서 바코드 스캔 후 원격 디스플레이로 제작의뢰서 표시
 */
router.post(
  '/',
  ipLimiter,
  userLimiter,
  async (req: Request, res: Response) => {
    try {
      // 1. 입력 검증
      const parsed = TriggerSchema.safeParse(req.body);
      if (!parsed.success) {
        logger.warn('trigger.validation_error: errors=%s, userId=%s, ip=%s',
          JSON.stringify(parsed.error.errors), req.user?.id, req.ip);
        return res.status(400).json({
          ok: false,
          reason: 'validation_error',
          errors: parsed.error.errors,
        });
      }

      const { screenId, jobNo } = parsed.data;
      const userId = req.user!.id;
      const userScopes = req.user!.scopes || [];

      // 2. 권한 확인 (display:screenId 스코프)
      const hasPermission = userScopes.includes(`display:${screenId}`) ||
                           userScopes.includes('display:*');
      if (!hasPermission) {
        logger.warn('trigger.forbidden: userId=%s, screenId=%s, ip=%s',
          userId, screenId, req.ip);
        return res.status(403).json({
          ok: false,
          reason: 'forbidden',
        });
      }

      // 3. txId 생성 및 메시지 구성
      const txId = uuidv4();
      const appUrl = process.env.APP_URL || 'https://app.example.com';
      const payload = {
        txId,
        eventType: 'navigate',
        screenId,
        jobNo,
        url: `${appUrl}/orders/${jobNo}`,
        timestamp: Date.now(),
        expiredAt: Date.now() + 60 * 1000,  // 1분 후 만료
      };

      // 4. Socket.IO 채널로 메시지 전송
      const io = req.app.get('io');  // Express 앱에 io 저장됨
      const result = emitToChannel(io, screenId, 'navigate', payload);

      // 5. 로깅
      if (result.ok) {
        logger.info('trigger.sent: txId=%s, screenId=%s, jobNo=%s, userId=%s, clientCount=%d, ip=%s',
          txId, screenId, jobNo, userId, result.clientCount, req.ip);
      } else {
        logger.warn('trigger.failed: txId=%s, screenId=%s, jobNo=%s, userId=%s, reason=%s, ip=%s',
          txId, screenId, jobNo, userId, result.reason, req.ip);
      }

      // 6. 응답
      if (!result.ok) {
        // 메시지 전송 실패해도 클라이언트 응답은 200 (async 처리)
        return res.status(503).json({
          ok: false,
          reason: result.reason,
          txId,
        });
      }

      res.json({
        ok: true,
        txId,
        clientCount: result.clientCount,
      });
    } catch (error) {
      logger.error('trigger.error: error=%s, userId=%s, ip=%s',
        (error as Error).message, req.user?.id, req.ip);
      res.status(500).json({
        ok: false,
        reason: 'internal_error',
      });
    }
  }
);

export const triggerRoutes = router;
```

---

### 3.4 서비스 레이어 설계

```typescript
// server/src/services/displayService.ts
import { logger } from '../utils/logger';

interface DisplayData {
  deviceId: string;
  screenId: string;
  name: string;
  purpose: string;
  orgId: string;
  lineId: string;
}

interface Display extends DisplayData {
  status: 'online' | 'offline';
  lastSeenAt: Date;
  createdAt: Date;
}

class DisplayService {
  private displays = new Map<string, Display>();

  /**
   * 디스플레이 등록 또는 업데이트
   */
  async register(data: DisplayData): Promise<Display> {
    const now = new Date();

    let display = this.displays.get(data.deviceId);
    if (display) {
      // 기존 디스플레이 업데이트
      display.lastSeenAt = now;
      display.status = 'online';
      logger.debug('display.updated: deviceId=%s', data.deviceId);
    } else {
      // 새 디스플레이 등록
      display = {
        ...data,
        status: 'online',
        lastSeenAt: now,
        createdAt: now,
      };
      this.displays.set(data.deviceId, display);
      logger.info('display.registered: deviceId=%s, screenId=%s',
        data.deviceId, data.screenId);
    }

    return display;
  }

  /**
   * 디스플레이 목록 조회
   */
  async getDisplays(filters: {
    lineId?: string;
    onlineOnly?: boolean;
  }): Promise<Display[]> {
    const now = Date.now();
    const OFFLINE_THRESHOLD = 60 * 1000;  // 60초

    let result = Array.from(this.displays.values());

    // 온라인 상태 업데이트 (60초 이상 미갱신 시 offline)
    result = result.map(d => ({
      ...d,
      status: (now - d.lastSeenAt.getTime()) > OFFLINE_THRESHOLD ? 'offline' : 'online',
    }));

    // 필터링
    if (filters.lineId) {
      result = result.filter(d => d.lineId === filters.lineId);
    }
    if (filters.onlineOnly) {
      result = result.filter(d => d.status === 'online');
    }

    return result;
  }

  /**
   * 정기적으로 오프라인 디스플레이 정리 (메모리 절약)
   */
  cleanupOfflineDisplays(maxIdleTime: number = 30 * 60 * 1000): number {
    const now = Date.now();
    let count = 0;

    for (const [deviceId, display] of this.displays) {
      if (now - display.lastSeenAt.getTime() > maxIdleTime) {
        this.displays.delete(deviceId);
        count++;
      }
    }

    if (count > 0) {
      logger.info('display.cleanup: removed=%d', count);
    }

    return count;
  }
}

export const displayService = new DisplayService();
```

```typescript
// server/src/services/pairingService.ts
import jwt, { SignOptions } from 'jsonwebtoken';
import { v4 as uuidv4 } from 'uuid';
import { logger } from '../utils/logger';

interface PairingSession {
  sessionId: string;
  code: string;  // 6자리 숫자
  status: 'pending' | 'approved' | 'expired';
  screenId?: string;
  token?: string;
  approvedBy?: string;
  createdAt: Date;
  expiresAt: Date;
}

class PairingService {
  private sessions = new Map<string, PairingSession>();
  private jwtSecret: string;

  constructor(jwtSecret: string) {
    this.jwtSecret = jwtSecret;
  }

  /**
   * QR 페어링 세션 생성
   */
  createSession(userId: string): Omit<PairingSession, 'token'> {
    const sessionId = uuidv4();
    const code = String(Math.floor(Math.random() * 1000000)).padStart(6, '0');
    const now = new Date();
    const expiresAt = new Date(now.getTime() + 5 * 60 * 1000);  // 5분

    const session: PairingSession = {
      sessionId,
      code,
      status: 'pending',
      createdAt: now,
      expiresAt,
    };

    this.sessions.set(sessionId, session);

    // 5분 후 자동 만료
    setTimeout(() => {
      const s = this.sessions.get(sessionId);
      if (s && s.status === 'pending') {
        s.status = 'expired';
        logger.info('pairing.expired: sessionId=%s', sessionId);
      }
    }, 5 * 60 * 1000);

    logger.info('pairing.session_created: sessionId=%s, userId=%s', sessionId, userId);

    return { sessionId, code, status: 'pending', createdAt: now, expiresAt };
  }

  /**
   * 세션 조회
   */
  getSession(sessionId: string): PairingSession | undefined {
    return this.sessions.get(sessionId);
  }

  /**
   * JWT 토큰 생성
   */
  generateToken(session: PairingSession, approvedBy: string): string {
    const payload = {
      sub: approvedBy,
      sessionId: session.sessionId,
      scopes: ['display:*'],  // 모든 화면 접근 허용
    };

    return jwt.sign(payload, this.jwtSecret, {
      expiresIn: '10m',
    } as SignOptions);
  }

  /**
   * 페어링 승인
   */
  approve(sessionId: string, token: string, approvedBy: string): void {
    const session = this.sessions.get(sessionId);
    if (session) {
      session.status = 'approved';
      session.token = token;
      session.approvedBy = approvedBy;
      logger.info('pairing.approved: sessionId=%s, approvedBy=%s', sessionId, approvedBy);
    }
  }
}

export const pairingService = new PairingService(process.env.SOCKET_JWT_SECRET || '');
```

---

## 4. 구현 가이드

### 4.1 구현 순서

**Phase 1: 기본 인프라 (1-2일)**
1. Express 라우터 파일 구조 생성
2. REST API 인증 미들웨어 구현
3. Zod 스키마 정의
4. 에러 응답 형식 표준화

**Phase 2: 디스플레이 관리 (1-2일)**
1. Display 서비스 구현 (인메모리 또는 SQLite)
2. `/api/displays/register` 엔드포인트
3. `/api/displays` 목록 조회
4. 온라인 상태 추적 로직

**Phase 3: 페어링 시스템 (2-3일)**
1. Pairing 서비스 구현
2. `/api/pair/qr` - QR 생성
3. `/api/pair/poll/:sessionId` - Long Polling
4. `/api/pair/approve` - 승인 처리

**Phase 4: 트리거 및 통합 (1-2일)**
1. Trigger 라우터 구현
2. emitToChannel과의 통합
3. 레이트 리미팅 설정
4. 로깅 통합

**Phase 5: 테스트 (2-3일)**
1. 단위 테스트
2. 통합 테스트
3. E2E 테스트
4. 성능/부하 테스트

---

### 4.2 의존성

**추가 필요 라이브러리:**
```json
{
  "dependencies": {
    "zod": "^3.22.0",
    "uuid": "^9.0.0",
    "jsonwebtoken": "^9.1.0",
    "express-rate-limit": "^7.0.0",
    "express": "^4.18.0"
  },
  "devDependencies": {
    "vitest": "^0.34.0",
    "@testing-library/react": "^14.0.0",
    "socket.io-client": "^4.7.0"
  }
}
```

---

### 4.3 환경변수 설정

```bash
# .env
PORT=3000
NODE_ENV=development
SOCKET_JWT_SECRET=your-secure-secret-key
CORS_ORIGINS=http://localhost:3000,http://localhost:3001
WS_URL=ws://localhost:3000
APP_URL=http://localhost:3000
LOG_LEVEL=info
```

---

### 4.4 테스트 전략

```typescript
// server/src/__tests__/api.trigger.test.ts
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import request from 'supertest';
import jwt from 'jsonwebtoken';

describe('POST /api/trigger', () => {
  let app: any;
  let token: string;

  beforeAll(async () => {
    // 테스트 앱 초기화
    token = jwt.sign({
      sub: 'user-123',
      scopes: ['display:screen:org:line'],
    }, 'test-secret');
  });

  it('should send navigate event to connected clients', async () => {
    const res = await request(app)
      .post('/api/trigger')
      .set('Authorization', `Bearer ${token}`)
      .send({
        screenId: 'screen:org:line',
        jobNo: 'JOB-001',
      });

    expect(res.status).toBe(200);
    expect(res.body.ok).toBe(true);
    expect(res.body.txId).toBeDefined();
  });

  it('should return 403 for unauthorized screenId', async () => {
    const res = await request(app)
      .post('/api/trigger')
      .set('Authorization', `Bearer ${token}`)
      .send({
        screenId: 'screen:other:org',
        jobNo: 'JOB-001',
      });

    expect(res.status).toBe(403);
    expect(res.body.ok).toBe(false);
  });

  it('should respect rate limiting', async () => {
    // 초당 10회 제한
    const promises = [];
    for (let i = 0; i < 15; i++) {
      promises.push(
        request(app)
          .post('/api/trigger')
          .set('Authorization', `Bearer ${token}`)
          .send({
            screenId: 'screen:org:line',
            jobNo: `JOB-${i}`,
          })
      );
    }

    const results = await Promise.all(promises);
    const successCount = results.filter(r => r.status === 200).length;
    const rateLimitedCount = results.filter(r => r.status === 429).length;

    expect(successCount).toBeLessThanOrEqual(10);
    expect(rateLimitedCount).toBeGreaterThan(0);
  });
});
```

---

### 4.5 성능 고려사항

1. **디스플레이 온라인 상태 확인:**
   - 60초마다 heartbeat 필수
   - 60초 이상 미갱신 시 offline 처리
   - 메모리 정리: 30분 이상 offline 상태 삭제

2. **페어링 세션 TTL:**
   - 5분 자동 만료
   - 만료된 세션 자동 정리

3. **메시지 idempotency:**
   - 최근 100개 txId 메모리 캐시
   - 중복 탐지 O(1) 성능

4. **레이트 리미팅:**
   - IP 기반: 초당 10회 (트리거)
   - 사용자 기반: 분당 100회

---

## 5. 요약 및 체크리스트

### 5.1 기존 코드 활용 가능 부분

✅ **Socket.IO 통합:**
- `/display` 네임스페이스 (T-012 완료)
- JWT 검증 (`verifyDisplayToken`)
- 채널 구독 (`subscribeToChannel`)
- 메시지 브로드캐스트 (`emitToChannel`)

✅ **인증/권한:**
- JWT 생성 및 검증 로직
- scopes 기반 권한 제어

✅ **로깅:**
- Pino 로거 설정
- 구조화된 로깅

### 5.2 새로 구현해야 할 부분

**Express REST API 레이어:**
- `expressAuthMiddleware` (Bearer 토큰)
- 4개 라우터: displays, pairing, triggers, channels
- 엔드포인트별 세분화된 레이트 리미팅

**서비스 레이어:**
- DisplayService (등록, 조회, 온라인 추적)
- PairingService (QR 세션, 승인)

**데이터 저장소:**
- 인메모리 또는 SQLite (개발용)
- PostgreSQL (프로덕션)

**테스트:**
- 단위 테스트 (Zod, JWT, 서비스)
- 통합 테스트 (API + Socket.IO)
- E2E 테스트 (Playwright)

---

이 분석을 기반으로 T-014 구현을 진행하시면 됩니다!
